/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201706;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 26;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __HAVE_GENERIC_SELECTION: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_INTN_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_UINTN_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const GODOT_API_VERSION: ::std::os::raw::c_uint = 1;
pub const GODOT_TRUE: ::std::os::raw::c_uint = 1;
pub const GODOT_FALSE: ::std::os::raw::c_uint = 0;
pub const _WCHAR_H: ::std::os::raw::c_uint = 1;
pub const __HAVE_FLOAT128: ::std::os::raw::c_uint = 0;
pub const __HAVE_DISTINCT_FLOAT128: ::std::os::raw::c_uint = 0;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const __wint_t_defined: ::std::os::raw::c_uint = 1;
pub const _WINT_T: ::std::os::raw::c_uint = 1;
pub const __mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_LOCALE_T_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES___LOCALE_T_H: ::std::os::raw::c_uint = 1;
pub const WEOF: ::std::os::raw::c_uint = 4294967295;
pub const GODOT_STRING_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_VECTOR2_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_VECTOR3_SIZE: ::std::os::raw::c_uint = 12;
pub const GODOT_BASIS_SIZE: ::std::os::raw::c_uint = 36;
pub const GODOT_QUAT_SIZE: ::std::os::raw::c_uint = 16;
pub const GODOT_TRANSFORM2D_SIZE: ::std::os::raw::c_uint = 24;
pub const GODOT_VARIANT_SIZE: ::std::os::raw::c_uint = 24;
pub const GODOT_ARRAY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_POOL_BYTE_ARRAY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_POOL_INT_ARRAY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_POOL_REAL_ARRAY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_POOL_STRING_ARRAY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_POOL_VECTOR2_ARRAY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_POOL_VECTOR3_ARRAY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_POOL_COLOR_ARRAY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_COLOR_SIZE: ::std::os::raw::c_uint = 16;
pub const GODOT_DICTIONARY_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_NODE_PATH_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_PLANE_SIZE: ::std::os::raw::c_uint = 16;
pub const GODOT_RECT3_SIZE: ::std::os::raw::c_uint = 24;
pub const GODOT_RID_SIZE: ::std::os::raw::c_uint = 8;
pub const GODOT_TRANSFORM_SIZE: ::std::os::raw::c_uint = 48;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const godot_error_GODOT_ERR_WTF: godot_error =
    godot_error::GODOT_ERR_OMFG_THIS_IS_VERY_VERY_BAD;
#[repr(u32)]
////// Error
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_error {
    GODOT_OK = 0,
    GODOT_FAILED = 1,
    GODOT_ERR_UNAVAILABLE = 2,
    GODOT_ERR_UNCONFIGURED = 3,
    GODOT_ERR_UNAUTHORIZED = 4,
    GODOT_ERR_PARAMETER_RANGE_ERROR = 5,
    GODOT_ERR_OUT_OF_MEMORY = 6,
    GODOT_ERR_FILE_NOT_FOUND = 7,
    GODOT_ERR_FILE_BAD_DRIVE = 8,
    GODOT_ERR_FILE_BAD_PATH = 9,
    GODOT_ERR_FILE_NO_PERMISSION = 10,
    GODOT_ERR_FILE_ALREADY_IN_USE = 11,
    GODOT_ERR_FILE_CANT_OPEN = 12,
    GODOT_ERR_FILE_CANT_WRITE = 13,
    GODOT_ERR_FILE_CANT_READ = 14,
    GODOT_ERR_FILE_UNRECOGNIZED = 15,
    GODOT_ERR_FILE_CORRUPT = 16,
    GODOT_ERR_FILE_MISSING_DEPENDENCIES = 17,
    GODOT_ERR_FILE_EOF = 18,
    GODOT_ERR_CANT_OPEN = 19,
    GODOT_ERR_CANT_CREATE = 20,
    GODOT_ERR_QUERY_FAILED = 21,
    GODOT_ERR_ALREADY_IN_USE = 22,
    GODOT_ERR_LOCKED = 23,
    GODOT_ERR_TIMEOUT = 24,
    GODOT_ERR_CANT_CONNECT = 25,
    GODOT_ERR_CANT_RESOLVE = 26,
    GODOT_ERR_CONNECTION_ERROR = 27,
    GODOT_ERR_CANT_AQUIRE_RESOURCE = 28,
    GODOT_ERR_CANT_FORK = 29,
    GODOT_ERR_INVALID_DATA = 30,
    GODOT_ERR_INVALID_PARAMETER = 31,
    GODOT_ERR_ALREADY_EXISTS = 32,
    GODOT_ERR_DOES_NOT_EXIST = 33,
    GODOT_ERR_DATABASE_CANT_READ = 34,
    GODOT_ERR_DATABASE_CANT_WRITE = 35,
    GODOT_ERR_COMPILATION_FAILED = 36,
    GODOT_ERR_METHOD_NOT_FOUND = 37,
    GODOT_ERR_LINK_FAILED = 38,
    GODOT_ERR_SCRIPT_FAILED = 39,
    GODOT_ERR_CYCLIC_LINK = 40,
    GODOT_ERR_INVALID_DECLARATION = 41,
    GODOT_ERR_DUPLICATE_SYMBOL = 42,
    GODOT_ERR_PARSE_ERROR = 43,
    GODOT_ERR_BUSY = 44,
    GODOT_ERR_SKIP = 45,
    GODOT_ERR_HELP = 46,
    GODOT_ERR_BUG = 47,
    GODOT_ERR_PRINTER_ON_FIRE = 48,
    GODOT_ERR_OMFG_THIS_IS_VERY_VERY_BAD = 49,
}
////// bool
pub type godot_bool = bool;
/////// int
pub type godot_int = ::std::os::raw::c_int;
/////// real
pub type godot_real = f32;
/////// Object (forward declared)
pub type godot_object = ::std::os::raw::c_void;
pub type wchar_t = ::std::os::raw::c_int;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
            usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE([u8; 0]);
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
    ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
    ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __locales as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
        const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
            * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
            * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __names as * const
        _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm([u8; 0]);
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t)
                  -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
                   -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t)
                  -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
                   -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(__s1: *const wchar_t, __s2: *const wchar_t)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t)
                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t,
                        __loc: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t,
                         __n: usize, __loc: locale_t)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
                   -> usize;
}
extern "C" {
    pub fn wcscoll_l(__s1: *const wchar_t, __s2: *const wchar_t,
                     __loc: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize,
                     __loc: locale_t) -> usize;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(__wcs: *const wchar_t, __wc: wchar_t)
                  -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t)
                   -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t)
                  -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(__s: *mut wchar_t, __delim: *const wchar_t,
                  __ptr: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const wchar_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(__s: *const wchar_t, __c: wchar_t, __n: usize)
                   -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
                   -> *mut wchar_t;
}
extern "C" {
    pub fn wmemmove(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
                    -> *mut wchar_t;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize)
                   -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                   __n: usize, __p: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t,
                   __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize,
                    __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize,
                  __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(__dst: *mut wchar_t,
                     __src: *mut *const ::std::os::raw::c_char, __len: usize,
                     __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsrtombs(__dst: *mut ::std::os::raw::c_char,
                     __src: *mut *const wchar_t, __len: usize,
                     __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsnrtowcs(__dst: *mut wchar_t,
                      __src: *mut *const ::std::os::raw::c_char, __nmc: usize,
                      __len: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsnrtombs(__dst: *mut ::std::os::raw::c_char,
                      __src: *mut *const wchar_t, __nwc: usize, __len: usize,
                      __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t)
                   -> f64;
}
extern "C" {
    pub fn wcstol(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                   __base: ::std::os::raw::c_int)
                   -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                    __base: ::std::os::raw::c_int)
                    -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t)
                  -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
                   -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize)
                           -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int)
                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...)
                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(__s: *mut wchar_t, __n: usize,
                    __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(__s: *mut __FILE, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag)
                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(__s: *mut wchar_t, __n: usize, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...)
                    -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...)
                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(__s: *mut __FILE, __format: *const wchar_t,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(__s: *const wchar_t, __format: *const wchar_t,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfwscanf"]
    pub fn vfwscanf1(__s: *mut __FILE, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag)
                    -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vswscanf"]
    pub fn vswscanf1(__s: *const wchar_t, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(__ws: *mut wchar_t, __n: ::std::os::raw::c_int,
                  __stream: *mut __FILE) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(__s: *mut wchar_t, __maxsize: usize,
                    __format: *const wchar_t, __tp: *const tm) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_string {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_string() {
    assert_eq!(::std::mem::size_of::<godot_string>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_string ) ));
    assert_eq! (::std::mem::align_of::<godot_string>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_string ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_string ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_string ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_string {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_string_new(r_dest: *mut godot_string);
}
extern "C" {
    pub fn godot_string_new_copy(r_dest: *mut godot_string,
                                 p_src: *const godot_string);
}
extern "C" {
    pub fn godot_string_new_data(r_dest: *mut godot_string,
                                 p_contents: *const ::std::os::raw::c_char,
                                 p_size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn godot_string_new_unicode_data(r_dest: *mut godot_string,
                                         p_contents: *const wchar_t,
                                         p_size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn godot_string_get_data(p_self: *const godot_string,
                                 p_dest: *mut ::std::os::raw::c_char,
                                 p_size: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn godot_string_operator_index(p_self: *mut godot_string,
                                       p_idx: godot_int) -> *mut wchar_t;
}
extern "C" {
    pub fn godot_string_c_str(p_self: *const godot_string)
                              -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn godot_string_unicode_str(p_self: *const godot_string)
                                    -> *const wchar_t;
}
extern "C" {
    pub fn godot_string_operator_equal(p_self: *const godot_string,
                                       p_b: *const godot_string)
                                       -> godot_bool;
}
extern "C" {
    pub fn godot_string_operator_less(p_self: *const godot_string,
                                      p_b: *const godot_string) -> godot_bool;
}
extern "C" {
    pub fn godot_string_operator_plus(p_self: *const godot_string,
                                      p_b: *const godot_string)
                                      -> godot_string;
}
extern "C" {
    pub fn godot_string_destroy(p_self: *mut godot_string);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_vector2 {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_vector2() {
    assert_eq!(::std::mem::size_of::<godot_vector2>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_vector2 ) ));
    assert_eq! (::std::mem::align_of::<godot_vector2>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_vector2 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_vector2 ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_vector2 ) , "::"
                , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_vector2 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_vector2_new(r_dest: *mut godot_vector2, p_x: godot_real,
                             p_y: godot_real);
}
extern "C" {
    pub fn godot_vector2_as_string(p_self: *const godot_vector2)
                                   -> godot_string;
}
extern "C" {
    pub fn godot_vector2_normalized(p_self: *const godot_vector2)
                                    -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_length(p_self: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_angle(p_self: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_length_squared(p_self: *const godot_vector2)
                                        -> godot_real;
}
extern "C" {
    pub fn godot_vector2_is_normalized(p_self: *const godot_vector2)
                                       -> godot_bool;
}
extern "C" {
    pub fn godot_vector2_distance_to(p_self: *const godot_vector2,
                                     p_to: *const godot_vector2)
                                     -> godot_real;
}
extern "C" {
    pub fn godot_vector2_distance_squared_to(p_self: *const godot_vector2,
                                             p_to: *const godot_vector2)
                                             -> godot_real;
}
extern "C" {
    pub fn godot_vector2_angle_to(p_self: *const godot_vector2,
                                  p_to: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_angle_to_point(p_self: *const godot_vector2,
                                        p_to: *const godot_vector2)
                                        -> godot_real;
}
extern "C" {
    pub fn godot_vector2_linear_interpolate(p_self: *const godot_vector2,
                                            p_b: *const godot_vector2,
                                            p_t: godot_real) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_cubic_interpolate(p_self: *const godot_vector2,
                                           p_b: *const godot_vector2,
                                           p_pre_a: *const godot_vector2,
                                           p_post_b: *const godot_vector2,
                                           p_t: godot_real) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_rotated(p_self: *const godot_vector2,
                                 p_phi: godot_real) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_tangent(p_self: *const godot_vector2)
                                 -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_floor(p_self: *const godot_vector2) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_snapped(p_self: *const godot_vector2,
                                 p_by: *const godot_vector2) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_aspect(p_self: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_dot(p_self: *const godot_vector2,
                             p_with: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_slide(p_self: *const godot_vector2,
                               p_n: *const godot_vector2) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_bounce(p_self: *const godot_vector2,
                                p_n: *const godot_vector2) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_reflect(p_self: *const godot_vector2,
                                 p_n: *const godot_vector2) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_abs(p_self: *const godot_vector2) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_clamped(p_self: *const godot_vector2,
                                 p_length: godot_real) -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_operator_add(p_self: *const godot_vector2,
                                      p_b: *const godot_vector2)
                                      -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_operator_substract(p_self: *const godot_vector2,
                                            p_b: *const godot_vector2)
                                            -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_operator_multiply_vector(p_self:
                                                  *const godot_vector2,
                                                  p_b: *const godot_vector2)
                                                  -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_operator_multiply_scalar(p_self:
                                                  *const godot_vector2,
                                                  p_b: godot_real)
                                                  -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_operator_divide_vector(p_self: *const godot_vector2,
                                                p_b: *const godot_vector2)
                                                -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_operator_divide_scalar(p_self: *const godot_vector2,
                                                p_b: godot_real)
                                                -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_operator_equal(p_self: *const godot_vector2,
                                        p_b: *const godot_vector2)
                                        -> godot_bool;
}
extern "C" {
    pub fn godot_vector2_operator_less(p_self: *const godot_vector2,
                                       p_b: *const godot_vector2)
                                       -> godot_bool;
}
extern "C" {
    pub fn godot_vector2_operator_neg(p_self: *const godot_vector2)
                                      -> godot_vector2;
}
extern "C" {
    pub fn godot_vector2_set_x(p_self: *mut godot_vector2, p_x: godot_real);
}
extern "C" {
    pub fn godot_vector2_set_y(p_self: *mut godot_vector2, p_y: godot_real);
}
extern "C" {
    pub fn godot_vector2_get_x(p_self: *const godot_vector2) -> godot_real;
}
extern "C" {
    pub fn godot_vector2_get_y(p_self: *const godot_vector2) -> godot_real;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_rect2 {
    pub _dont_touch_that: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_godot_rect2() {
    assert_eq!(::std::mem::size_of::<godot_rect2>() , 16usize , concat ! (
               "Size of: " , stringify ! ( godot_rect2 ) ));
    assert_eq! (::std::mem::align_of::<godot_rect2>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_rect2 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_rect2 ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_rect2 ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_rect2 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_rect2_new_with_position_and_size(r_dest: *mut godot_rect2,
                                                  p_pos: *const godot_vector2,
                                                  p_size:
                                                  *const godot_vector2);
}
extern "C" {
    pub fn godot_rect2_new(r_dest: *mut godot_rect2, p_x: godot_real,
                           p_y: godot_real, p_width: godot_real,
                           p_height: godot_real);
}
extern "C" {
    pub fn godot_rect2_as_string(p_self: *const godot_rect2) -> godot_string;
}
extern "C" {
    pub fn godot_rect2_get_area(p_self: *const godot_rect2) -> godot_real;
}
extern "C" {
    pub fn godot_rect2_intersects(p_self: *const godot_rect2,
                                  p_b: *const godot_rect2) -> godot_bool;
}
extern "C" {
    pub fn godot_rect2_encloses(p_self: *const godot_rect2,
                                p_b: *const godot_rect2) -> godot_bool;
}
extern "C" {
    pub fn godot_rect2_has_no_area(p_self: *const godot_rect2) -> godot_bool;
}
extern "C" {
    pub fn godot_rect2_clip(p_self: *const godot_rect2,
                            p_b: *const godot_rect2) -> godot_rect2;
}
extern "C" {
    pub fn godot_rect2_merge(p_self: *const godot_rect2,
                             p_b: *const godot_rect2) -> godot_rect2;
}
extern "C" {
    pub fn godot_rect2_has_point(p_self: *const godot_rect2,
                                 p_point: *const godot_vector2) -> godot_bool;
}
extern "C" {
    pub fn godot_rect2_grow(p_self: *const godot_rect2, p_by: godot_real)
                            -> godot_rect2;
}
extern "C" {
    pub fn godot_rect2_expand(p_self: *const godot_rect2,
                              p_to: *const godot_vector2) -> godot_rect2;
}
extern "C" {
    pub fn godot_rect2_operator_equal(p_self: *const godot_rect2,
                                      p_b: *const godot_rect2) -> godot_bool;
}
extern "C" {
    pub fn godot_rect2_get_position(p_self: *const godot_rect2)
                                    -> godot_vector2;
}
extern "C" {
    pub fn godot_rect2_get_size(p_self: *const godot_rect2) -> godot_vector2;
}
extern "C" {
    pub fn godot_rect2_set_position(p_self: *mut godot_rect2,
                                    p_pos: *const godot_vector2);
}
extern "C" {
    pub fn godot_rect2_set_size(p_self: *mut godot_rect2,
                                p_size: *const godot_vector2);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_vector3 {
    pub _dont_touch_that: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_godot_vector3() {
    assert_eq!(::std::mem::size_of::<godot_vector3>() , 12usize , concat ! (
               "Size of: " , stringify ! ( godot_vector3 ) ));
    assert_eq! (::std::mem::align_of::<godot_vector3>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_vector3 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_vector3 ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_vector3 ) , "::"
                , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_vector3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct godot_basis {
    pub _dont_touch_that: [u8; 36usize],
}
#[test]
fn bindgen_test_layout_godot_basis() {
    assert_eq!(::std::mem::size_of::<godot_basis>() , 36usize , concat ! (
               "Size of: " , stringify ! ( godot_basis ) ));
    assert_eq! (::std::mem::align_of::<godot_basis>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_basis ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_basis ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_basis ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_quat {
    pub _dont_touch_that: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_godot_quat() {
    assert_eq!(::std::mem::size_of::<godot_quat>() , 16usize , concat ! (
               "Size of: " , stringify ! ( godot_quat ) ));
    assert_eq! (::std::mem::align_of::<godot_quat>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_quat ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_quat ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_quat ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_quat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_quat_new(r_dest: *mut godot_quat, p_x: godot_real,
                          p_y: godot_real, p_z: godot_real, p_w: godot_real);
}
extern "C" {
    pub fn godot_quat_new_with_axis_angle(r_dest: *mut godot_quat,
                                          p_axis: *const godot_vector3,
                                          p_angle: godot_real);
}
extern "C" {
    pub fn godot_quat_get_x(p_self: *const godot_quat) -> godot_real;
}
extern "C" {
    pub fn godot_quat_set_x(p_self: *mut godot_quat, val: godot_real);
}
extern "C" {
    pub fn godot_quat_get_y(p_self: *const godot_quat) -> godot_real;
}
extern "C" {
    pub fn godot_quat_set_y(p_self: *mut godot_quat, val: godot_real);
}
extern "C" {
    pub fn godot_quat_get_z(p_self: *const godot_quat) -> godot_real;
}
extern "C" {
    pub fn godot_quat_set_z(p_self: *mut godot_quat, val: godot_real);
}
extern "C" {
    pub fn godot_quat_get_w(p_self: *const godot_quat) -> godot_real;
}
extern "C" {
    pub fn godot_quat_set_w(p_self: *mut godot_quat, val: godot_real);
}
extern "C" {
    pub fn godot_quat_as_string(p_self: *const godot_quat) -> godot_string;
}
extern "C" {
    pub fn godot_quat_length(p_self: *const godot_quat) -> godot_real;
}
extern "C" {
    pub fn godot_quat_length_squared(p_self: *const godot_quat) -> godot_real;
}
extern "C" {
    pub fn godot_quat_normalized(p_self: *const godot_quat) -> godot_quat;
}
extern "C" {
    pub fn godot_quat_is_normalized(p_self: *const godot_quat) -> godot_bool;
}
extern "C" {
    pub fn godot_quat_inverse(p_self: *const godot_quat) -> godot_quat;
}
extern "C" {
    pub fn godot_quat_dot(p_self: *const godot_quat, p_b: *const godot_quat)
                          -> godot_real;
}
extern "C" {
    pub fn godot_quat_xform(p_self: *const godot_quat,
                            p_v: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_quat_slerp(p_self: *const godot_quat, p_b: *const godot_quat,
                            p_t: godot_real) -> godot_quat;
}
extern "C" {
    pub fn godot_quat_slerpni(p_self: *const godot_quat,
                              p_b: *const godot_quat, p_t: godot_real)
                              -> godot_quat;
}
extern "C" {
    pub fn godot_quat_cubic_slerp(p_self: *const godot_quat,
                                  p_b: *const godot_quat,
                                  p_pre_a: *const godot_quat,
                                  p_post_b: *const godot_quat,
                                  p_t: godot_real) -> godot_quat;
}
extern "C" {
    pub fn godot_quat_operator_multiply(p_self: *const godot_quat,
                                        p_b: godot_real) -> godot_quat;
}
extern "C" {
    pub fn godot_quat_operator_add(p_self: *const godot_quat,
                                   p_b: *const godot_quat) -> godot_quat;
}
extern "C" {
    pub fn godot_quat_operator_substract(p_self: *const godot_quat,
                                         p_b: *const godot_quat)
                                         -> godot_quat;
}
extern "C" {
    pub fn godot_quat_operator_divide(p_self: *const godot_quat,
                                      p_b: godot_real) -> godot_quat;
}
extern "C" {
    pub fn godot_quat_operator_equal(p_self: *const godot_quat,
                                     p_b: *const godot_quat) -> godot_bool;
}
extern "C" {
    pub fn godot_quat_operator_neg(p_self: *const godot_quat) -> godot_quat;
}
extern "C" {
    pub fn godot_basis_new_with_rows(r_dest: *mut godot_basis,
                                     p_x_axis: *const godot_vector3,
                                     p_y_axis: *const godot_vector3,
                                     p_z_axis: *const godot_vector3);
}
extern "C" {
    pub fn godot_basis_new_with_axis_and_angle(r_dest: *mut godot_basis,
                                               p_axis: *const godot_vector3,
                                               p_phi: godot_real);
}
extern "C" {
    pub fn godot_basis_new_with_euler(r_dest: *mut godot_basis,
                                      p_euler: *const godot_vector3);
}
extern "C" {
    pub fn godot_basis_as_string(p_self: *const godot_basis) -> godot_string;
}
extern "C" {
    pub fn godot_basis_inverse(p_self: *const godot_basis) -> godot_basis;
}
extern "C" {
    pub fn godot_basis_transposed(p_self: *const godot_basis) -> godot_basis;
}
extern "C" {
    pub fn godot_basis_orthonormalized(p_self: *const godot_basis)
                                       -> godot_basis;
}
extern "C" {
    pub fn godot_basis_determinant(p_self: *const godot_basis) -> godot_real;
}
extern "C" {
    pub fn godot_basis_rotated(p_self: *const godot_basis,
                               p_axis: *const godot_vector3,
                               p_phi: godot_real) -> godot_basis;
}
extern "C" {
    pub fn godot_basis_scaled(p_self: *const godot_basis,
                              p_scale: *const godot_vector3) -> godot_basis;
}
extern "C" {
    pub fn godot_basis_set_scale(p_self: *mut godot_basis,
                                 p_scale: *const godot_vector3);
}
extern "C" {
    pub fn godot_basis_set_rotation_euler(p_self: *mut godot_basis,
                                          p_euler: *const godot_vector3);
}
extern "C" {
    pub fn godot_basis_set_rotation_axis_angle(p_self: *mut godot_basis,
                                               p_axis: *const godot_vector3,
                                               p_angle: godot_real);
}
extern "C" {
    pub fn godot_basis_get_scale(p_self: *const godot_basis) -> godot_vector3;
}
extern "C" {
    pub fn godot_basis_get_euler(p_self: *const godot_basis) -> godot_vector3;
}
extern "C" {
    pub fn godot_basis_tdotx(p_self: *const godot_basis,
                             p_with: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_basis_tdoty(p_self: *const godot_basis,
                             p_with: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_basis_tdotz(p_self: *const godot_basis,
                             p_with: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_basis_xform(p_self: *const godot_basis,
                             p_v: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_basis_xform_inv(p_self: *const godot_basis,
                                 p_v: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_basis_get_orthogonal_index(p_self: *const godot_basis)
                                            -> godot_int;
}
extern "C" {
    pub fn godot_basis_new(r_dest: *mut godot_basis);
}
extern "C" {
    pub fn godot_basis_new_with_euler_quat(r_dest: *mut godot_basis,
                                           p_euler: *const godot_quat);
}
extern "C" {
    pub fn godot_basis_get_elements(p_self: *mut godot_basis,
                                    p_elements: *mut godot_vector3);
}
extern "C" {
    pub fn godot_basis_get_axis(p_self: *const godot_basis, p_axis: godot_int)
                                -> godot_vector3;
}
extern "C" {
    pub fn godot_basis_set_axis(p_self: *mut godot_basis, p_axis: godot_int,
                                p_value: *const godot_vector3);
}
extern "C" {
    pub fn godot_basis_get_row(p_self: *const godot_basis, p_row: godot_int)
                               -> godot_vector3;
}
extern "C" {
    pub fn godot_basis_set_row(p_self: *mut godot_basis, p_row: godot_int,
                               p_value: *const godot_vector3);
}
extern "C" {
    pub fn godot_basis_operator_equal(p_self: *const godot_basis,
                                      p_b: *const godot_basis) -> godot_bool;
}
extern "C" {
    pub fn godot_basis_operator_add(p_self: *const godot_basis,
                                    p_b: *const godot_basis) -> godot_basis;
}
extern "C" {
    pub fn godot_basis_operator_substract(p_self: *const godot_basis,
                                          p_b: *const godot_basis)
                                          -> godot_basis;
}
extern "C" {
    pub fn godot_basis_operator_multiply_vector(p_self: *const godot_basis,
                                                p_b: *const godot_basis)
                                                -> godot_basis;
}
extern "C" {
    pub fn godot_basis_operator_multiply_scalar(p_self: *const godot_basis,
                                                p_b: godot_real)
                                                -> godot_basis;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_vector3_axis {
    GODOT_VECTOR3_AXIS_X = 0,
    GODOT_VECTOR3_AXIS_Y = 1,
    GODOT_VECTOR3_AXIS_Z = 2,
}
extern "C" {
    pub fn godot_vector3_new(r_dest: *mut godot_vector3, p_x: godot_real,
                             p_y: godot_real, p_z: godot_real);
}
extern "C" {
    pub fn godot_vector3_as_string(p_self: *const godot_vector3)
                                   -> godot_string;
}
extern "C" {
    pub fn godot_vector3_min_axis(p_self: *const godot_vector3) -> godot_int;
}
extern "C" {
    pub fn godot_vector3_max_axis(p_self: *const godot_vector3) -> godot_int;
}
extern "C" {
    pub fn godot_vector3_length(p_self: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_vector3_length_squared(p_self: *const godot_vector3)
                                        -> godot_real;
}
extern "C" {
    pub fn godot_vector3_is_normalized(p_self: *const godot_vector3)
                                       -> godot_bool;
}
extern "C" {
    pub fn godot_vector3_normalized(p_self: *const godot_vector3)
                                    -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_inverse(p_self: *const godot_vector3)
                                 -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_snapped(p_self: *const godot_vector3,
                                 p_by: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_rotated(p_self: *const godot_vector3,
                                 p_axis: *const godot_vector3,
                                 p_phi: godot_real) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_linear_interpolate(p_self: *const godot_vector3,
                                            p_b: *const godot_vector3,
                                            p_t: godot_real) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_cubic_interpolate(p_self: *const godot_vector3,
                                           p_b: *const godot_vector3,
                                           p_pre_a: *const godot_vector3,
                                           p_post_b: *const godot_vector3,
                                           p_t: godot_real) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_dot(p_self: *const godot_vector3,
                             p_b: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_vector3_cross(p_self: *const godot_vector3,
                               p_b: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_outer(p_self: *const godot_vector3,
                               p_b: *const godot_vector3) -> godot_basis;
}
extern "C" {
    pub fn godot_vector3_to_diagonal_matrix(p_self: *const godot_vector3)
                                            -> godot_basis;
}
extern "C" {
    pub fn godot_vector3_abs(p_self: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_floor(p_self: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_ceil(p_self: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_distance_to(p_self: *const godot_vector3,
                                     p_b: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_vector3_distance_squared_to(p_self: *const godot_vector3,
                                             p_b: *const godot_vector3)
                                             -> godot_real;
}
extern "C" {
    pub fn godot_vector3_angle_to(p_self: *const godot_vector3,
                                  p_to: *const godot_vector3) -> godot_real;
}
extern "C" {
    pub fn godot_vector3_slide(p_self: *const godot_vector3,
                               p_n: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_bounce(p_self: *const godot_vector3,
                                p_n: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_reflect(p_self: *const godot_vector3,
                                 p_n: *const godot_vector3) -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_operator_add(p_self: *const godot_vector3,
                                      p_b: *const godot_vector3)
                                      -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_operator_substract(p_self: *const godot_vector3,
                                            p_b: *const godot_vector3)
                                            -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_operator_multiply_vector(p_self:
                                                  *const godot_vector3,
                                                  p_b: *const godot_vector3)
                                                  -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_operator_multiply_scalar(p_self:
                                                  *const godot_vector3,
                                                  p_b: godot_real)
                                                  -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_operator_divide_vector(p_self: *const godot_vector3,
                                                p_b: *const godot_vector3)
                                                -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_operator_divide_scalar(p_self: *const godot_vector3,
                                                p_b: godot_real)
                                                -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_operator_equal(p_self: *const godot_vector3,
                                        p_b: *const godot_vector3)
                                        -> godot_bool;
}
extern "C" {
    pub fn godot_vector3_operator_less(p_self: *const godot_vector3,
                                       p_b: *const godot_vector3)
                                       -> godot_bool;
}
extern "C" {
    pub fn godot_vector3_operator_neg(p_self: *const godot_vector3)
                                      -> godot_vector3;
}
extern "C" {
    pub fn godot_vector3_set_axis(p_self: *mut godot_vector3,
                                  p_axis: godot_vector3_axis,
                                  p_val: godot_real);
}
extern "C" {
    pub fn godot_vector3_get_axis(p_self: *const godot_vector3,
                                  p_axis: godot_vector3_axis) -> godot_real;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_transform2d {
    pub _dont_touch_that: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_godot_transform2d() {
    assert_eq!(::std::mem::size_of::<godot_transform2d>() , 24usize , concat !
    ( "Size of: " , stringify ! ( godot_transform2d ) ));
    assert_eq! (::std::mem::align_of::<godot_transform2d>() , 1usize , concat
    ! ( "Alignment of " , stringify ! ( godot_transform2d ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_transform2d ) ) . _dont_touch_that
            as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_transform2d ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_transform2d {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_variant {
    pub _dont_touch_that: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_godot_variant() {
    assert_eq!(::std::mem::size_of::<godot_variant>() , 24usize , concat ! (
               "Size of: " , stringify ! ( godot_variant ) ));
    assert_eq! (::std::mem::align_of::<godot_variant>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_variant ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_variant ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_variant ) , "::"
                , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_variant {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_variant_type {
    GODOT_VARIANT_TYPE_NIL = 0,
    GODOT_VARIANT_TYPE_BOOL = 1,
    GODOT_VARIANT_TYPE_INT = 2,
    GODOT_VARIANT_TYPE_REAL = 3,
    GODOT_VARIANT_TYPE_STRING = 4,
    GODOT_VARIANT_TYPE_VECTOR2 = 5,
    GODOT_VARIANT_TYPE_RECT2 = 6,
    GODOT_VARIANT_TYPE_VECTOR3 = 7,
    GODOT_VARIANT_TYPE_TRANSFORM2D = 8,
    GODOT_VARIANT_TYPE_PLANE = 9,
    GODOT_VARIANT_TYPE_QUAT = 10,
    GODOT_VARIANT_TYPE_RECT3 = 11,
    GODOT_VARIANT_TYPE_BASIS = 12,
    GODOT_VARIANT_TYPE_TRANSFORM = 13,
    GODOT_VARIANT_TYPE_COLOR = 14,
    GODOT_VARIANT_TYPE_NODE_PATH = 15,
    GODOT_VARIANT_TYPE_RID = 16,
    GODOT_VARIANT_TYPE_OBJECT = 17,
    GODOT_VARIANT_TYPE_DICTIONARY = 18,
    GODOT_VARIANT_TYPE_ARRAY = 19,
    GODOT_VARIANT_TYPE_POOL_BYTE_ARRAY = 20,
    GODOT_VARIANT_TYPE_POOL_INT_ARRAY = 21,
    GODOT_VARIANT_TYPE_POOL_REAL_ARRAY = 22,
    GODOT_VARIANT_TYPE_POOL_STRING_ARRAY = 23,
    GODOT_VARIANT_TYPE_POOL_VECTOR2_ARRAY = 24,
    GODOT_VARIANT_TYPE_POOL_VECTOR3_ARRAY = 25,
    GODOT_VARIANT_TYPE_POOL_COLOR_ARRAY = 26,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_variant_call_error_error {
    GODOT_CALL_ERROR_CALL_OK = 0,
    GODOT_CALL_ERROR_CALL_ERROR_INVALID_METHOD = 1,
    GODOT_CALL_ERROR_CALL_ERROR_INVALID_ARGUMENT = 2,
    GODOT_CALL_ERROR_CALL_ERROR_TOO_MANY_ARGUMENTS = 3,
    GODOT_CALL_ERROR_CALL_ERROR_TOO_FEW_ARGUMENTS = 4,
    GODOT_CALL_ERROR_CALL_ERROR_INSTANCE_IS_NULL = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_variant_call_error {
    pub error: godot_variant_call_error_error,
    pub argument: ::std::os::raw::c_int,
    pub expected: godot_variant_type,
}
#[test]
fn bindgen_test_layout_godot_variant_call_error() {
    assert_eq!(::std::mem::size_of::<godot_variant_call_error>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_variant_call_error ) ));
    assert_eq! (::std::mem::align_of::<godot_variant_call_error>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_variant_call_error ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_variant_call_error ) ) . error as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_variant_call_error ) , "::" , stringify ! ( error ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_variant_call_error ) ) . argument
            as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_variant_call_error ) , "::" , stringify ! ( argument )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_variant_call_error ) ) . expected
            as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_variant_call_error ) , "::" , stringify ! ( expected )
                ));
}
impl Clone for godot_variant_call_error {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_array() {
    assert_eq!(::std::mem::size_of::<godot_array>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_array ) ));
    assert_eq! (::std::mem::align_of::<godot_array>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_array ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_array ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_array ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_byte_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_byte_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_byte_array>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( godot_pool_byte_array )
               ));
    assert_eq! (::std::mem::align_of::<godot_pool_byte_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_byte_array ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_pool_byte_array ) ) .
            _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_byte_array )
                , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_byte_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_int_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_int_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_int_array>() , 8usize , concat
    ! ( "Size of: " , stringify ! ( godot_pool_int_array ) ));
    assert_eq! (::std::mem::align_of::<godot_pool_int_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_int_array ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_pool_int_array ) ) .
            _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_int_array )
                , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_int_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_real_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_real_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_real_array>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( godot_pool_real_array )
               ));
    assert_eq! (::std::mem::align_of::<godot_pool_real_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_real_array ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_pool_real_array ) ) .
            _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_real_array )
                , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_real_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_string_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_string_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_string_array>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_pool_string_array ) ));
    assert_eq! (::std::mem::align_of::<godot_pool_string_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_string_array ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_pool_string_array ) ) .
            _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_string_array
                ) , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_string_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_vector2_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_vector2_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_vector2_array>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_pool_vector2_array ) ));
    assert_eq! (::std::mem::align_of::<godot_pool_vector2_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_vector2_array ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_pool_vector2_array ) ) .
            _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_pool_vector2_array ) , "::" , stringify ! (
                _dont_touch_that ) ));
}
impl Clone for godot_pool_vector2_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_vector3_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_vector3_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_vector3_array>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_pool_vector3_array ) ));
    assert_eq! (::std::mem::align_of::<godot_pool_vector3_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_vector3_array ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_pool_vector3_array ) ) .
            _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_pool_vector3_array ) , "::" , stringify ! (
                _dont_touch_that ) ));
}
impl Clone for godot_pool_vector3_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_pool_color_array {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_pool_color_array() {
    assert_eq!(::std::mem::size_of::<godot_pool_color_array>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( godot_pool_color_array )
               ));
    assert_eq! (::std::mem::align_of::<godot_pool_color_array>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_pool_color_array ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_pool_color_array ) ) .
            _dont_touch_that as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_pool_color_array
                ) , "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_pool_color_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_color {
    pub _dont_touch_that: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_godot_color() {
    assert_eq!(::std::mem::size_of::<godot_color>() , 16usize , concat ! (
               "Size of: " , stringify ! ( godot_color ) ));
    assert_eq! (::std::mem::align_of::<godot_color>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_color ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_color ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_color ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_color {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_color_new_rgba(r_dest: *mut godot_color, p_r: godot_real,
                                p_g: godot_real, p_b: godot_real,
                                p_a: godot_real);
}
extern "C" {
    pub fn godot_color_new_rgb(r_dest: *mut godot_color, p_r: godot_real,
                               p_g: godot_real, p_b: godot_real);
}
extern "C" {
    pub fn godot_color_get_r(p_self: *const godot_color) -> godot_real;
}
extern "C" {
    pub fn godot_color_set_r(p_self: *mut godot_color, r: godot_real);
}
extern "C" {
    pub fn godot_color_get_g(p_self: *const godot_color) -> godot_real;
}
extern "C" {
    pub fn godot_color_set_g(p_self: *mut godot_color, g: godot_real);
}
extern "C" {
    pub fn godot_color_get_b(p_self: *const godot_color) -> godot_real;
}
extern "C" {
    pub fn godot_color_set_b(p_self: *mut godot_color, b: godot_real);
}
extern "C" {
    pub fn godot_color_get_a(p_self: *const godot_color) -> godot_real;
}
extern "C" {
    pub fn godot_color_set_a(p_self: *mut godot_color, a: godot_real);
}
extern "C" {
    pub fn godot_color_get_h(p_self: *const godot_color) -> godot_real;
}
extern "C" {
    pub fn godot_color_get_s(p_self: *const godot_color) -> godot_real;
}
extern "C" {
    pub fn godot_color_get_v(p_self: *const godot_color) -> godot_real;
}
extern "C" {
    pub fn godot_color_as_string(p_self: *const godot_color) -> godot_string;
}
extern "C" {
    pub fn godot_color_to_32(p_self: *const godot_color) -> godot_int;
}
extern "C" {
    pub fn godot_color_to_ARGB32(p_self: *const godot_color) -> godot_int;
}
extern "C" {
    pub fn godot_color_gray(p_self: *const godot_color) -> godot_real;
}
extern "C" {
    pub fn godot_color_inverted(p_self: *const godot_color) -> godot_color;
}
extern "C" {
    pub fn godot_color_contrasted(p_self: *const godot_color) -> godot_color;
}
extern "C" {
    pub fn godot_color_linear_interpolate(p_self: *const godot_color,
                                          p_b: *const godot_color,
                                          p_t: godot_real) -> godot_color;
}
extern "C" {
    pub fn godot_color_blend(p_self: *const godot_color,
                             p_over: *const godot_color) -> godot_color;
}
extern "C" {
    pub fn godot_color_to_html(p_self: *const godot_color,
                               p_with_alpha: godot_bool) -> godot_string;
}
extern "C" {
    pub fn godot_color_operator_equal(p_self: *const godot_color,
                                      p_b: *const godot_color) -> godot_bool;
}
extern "C" {
    pub fn godot_color_operator_less(p_self: *const godot_color,
                                     p_b: *const godot_color) -> godot_bool;
}
extern "C" {
    pub fn godot_pool_byte_array_new(r_dest: *mut godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_byte_array_new_copy(r_dest: *mut godot_pool_byte_array,
                                          p_src:
                                          *const godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_byte_array_new_with_array(r_dest:
                                                *mut godot_pool_byte_array,
                                                p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_byte_array_append(p_self: *mut godot_pool_byte_array,
                                        p_data: u8);
}
extern "C" {
    pub fn godot_pool_byte_array_append_array(p_self:
                                              *mut godot_pool_byte_array,
                                              p_array:
                                              *const godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_byte_array_insert(p_self: *mut godot_pool_byte_array,
                                        p_idx: godot_int, p_data: u8)
                                        -> godot_error;
}
extern "C" {
    pub fn godot_pool_byte_array_invert(p_self: *mut godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_byte_array_push_back(p_self: *mut godot_pool_byte_array,
                                           p_data: u8);
}
extern "C" {
    pub fn godot_pool_byte_array_remove(p_self: *mut godot_pool_byte_array,
                                        p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_byte_array_resize(p_self: *mut godot_pool_byte_array,
                                        p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_byte_array_set(p_self: *mut godot_pool_byte_array,
                                     p_idx: godot_int, p_data: u8);
}
extern "C" {
    pub fn godot_pool_byte_array_get(p_self: *const godot_pool_byte_array,
                                     p_idx: godot_int) -> u8;
}
extern "C" {
    pub fn godot_pool_byte_array_size(p_self: *const godot_pool_byte_array)
                                      -> godot_int;
}
extern "C" {
    pub fn godot_pool_byte_array_destroy(p_self: *mut godot_pool_byte_array);
}
extern "C" {
    pub fn godot_pool_int_array_new(r_dest: *mut godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_int_array_new_copy(r_dest: *mut godot_pool_int_array,
                                         p_src: *const godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_int_array_new_with_array(r_dest:
                                               *mut godot_pool_int_array,
                                               p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_int_array_append(p_self: *mut godot_pool_int_array,
                                       p_data: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_append_array(p_self:
                                             *mut godot_pool_int_array,
                                             p_array:
                                             *const godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_int_array_insert(p_self: *mut godot_pool_int_array,
                                       p_idx: godot_int, p_data: godot_int)
                                       -> godot_error;
}
extern "C" {
    pub fn godot_pool_int_array_invert(p_self: *mut godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_int_array_push_back(p_self: *mut godot_pool_int_array,
                                          p_data: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_remove(p_self: *mut godot_pool_int_array,
                                       p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_resize(p_self: *mut godot_pool_int_array,
                                       p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_set(p_self: *mut godot_pool_int_array,
                                    p_idx: godot_int, p_data: godot_int);
}
extern "C" {
    pub fn godot_pool_int_array_get(p_self: *const godot_pool_int_array,
                                    p_idx: godot_int) -> godot_int;
}
extern "C" {
    pub fn godot_pool_int_array_size(p_self: *const godot_pool_int_array)
                                     -> godot_int;
}
extern "C" {
    pub fn godot_pool_int_array_destroy(p_self: *mut godot_pool_int_array);
}
extern "C" {
    pub fn godot_pool_real_array_new(r_dest: *mut godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_real_array_new_copy(r_dest: *mut godot_pool_real_array,
                                          p_src:
                                          *const godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_real_array_new_with_array(r_dest:
                                                *mut godot_pool_real_array,
                                                p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_real_array_append(p_self: *mut godot_pool_real_array,
                                        p_data: godot_real);
}
extern "C" {
    pub fn godot_pool_real_array_append_array(p_self:
                                              *mut godot_pool_real_array,
                                              p_array:
                                              *const godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_real_array_insert(p_self: *mut godot_pool_real_array,
                                        p_idx: godot_int, p_data: godot_real)
                                        -> godot_error;
}
extern "C" {
    pub fn godot_pool_real_array_invert(p_self: *mut godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_real_array_push_back(p_self: *mut godot_pool_real_array,
                                           p_data: godot_real);
}
extern "C" {
    pub fn godot_pool_real_array_remove(p_self: *mut godot_pool_real_array,
                                        p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_real_array_resize(p_self: *mut godot_pool_real_array,
                                        p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_real_array_set(p_self: *mut godot_pool_real_array,
                                     p_idx: godot_int, p_data: godot_real);
}
extern "C" {
    pub fn godot_pool_real_array_get(p_self: *const godot_pool_real_array,
                                     p_idx: godot_int) -> godot_real;
}
extern "C" {
    pub fn godot_pool_real_array_size(p_self: *const godot_pool_real_array)
                                      -> godot_int;
}
extern "C" {
    pub fn godot_pool_real_array_destroy(p_self: *mut godot_pool_real_array);
}
extern "C" {
    pub fn godot_pool_string_array_new(r_dest: *mut godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_string_array_new_copy(r_dest:
                                            *mut godot_pool_string_array,
                                            p_src:
                                            *const godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_string_array_new_with_array(r_dest:
                                                  *mut godot_pool_string_array,
                                                  p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_string_array_append(p_self:
                                          *mut godot_pool_string_array,
                                          p_data: *const godot_string);
}
extern "C" {
    pub fn godot_pool_string_array_append_array(p_self:
                                                *mut godot_pool_string_array,
                                                p_array:
                                                *const godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_string_array_insert(p_self:
                                          *mut godot_pool_string_array,
                                          p_idx: godot_int,
                                          p_data: *const godot_string)
                                          -> godot_error;
}
extern "C" {
    pub fn godot_pool_string_array_invert(p_self:
                                          *mut godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_string_array_push_back(p_self:
                                             *mut godot_pool_string_array,
                                             p_data: *const godot_string);
}
extern "C" {
    pub fn godot_pool_string_array_remove(p_self:
                                          *mut godot_pool_string_array,
                                          p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_string_array_resize(p_self:
                                          *mut godot_pool_string_array,
                                          p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_string_array_set(p_self: *mut godot_pool_string_array,
                                       p_idx: godot_int,
                                       p_data: *const godot_string);
}
extern "C" {
    pub fn godot_pool_string_array_get(p_self: *const godot_pool_string_array,
                                       p_idx: godot_int) -> godot_string;
}
extern "C" {
    pub fn godot_pool_string_array_size(p_self:
                                        *const godot_pool_string_array)
                                        -> godot_int;
}
extern "C" {
    pub fn godot_pool_string_array_destroy(p_self:
                                           *mut godot_pool_string_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_new(r_dest:
                                        *mut godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_new_copy(r_dest:
                                             *mut godot_pool_vector2_array,
                                             p_src:
                                             *const godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_new_with_array(r_dest:
                                                   *mut godot_pool_vector2_array,
                                                   p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_append(p_self:
                                           *mut godot_pool_vector2_array,
                                           p_data: *const godot_vector2);
}
extern "C" {
    pub fn godot_pool_vector2_array_append_array(p_self:
                                                 *mut godot_pool_vector2_array,
                                                 p_array:
                                                 *const godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_insert(p_self:
                                           *mut godot_pool_vector2_array,
                                           p_idx: godot_int,
                                           p_data: *const godot_vector2)
                                           -> godot_error;
}
extern "C" {
    pub fn godot_pool_vector2_array_invert(p_self:
                                           *mut godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector2_array_push_back(p_self:
                                              *mut godot_pool_vector2_array,
                                              p_data: *const godot_vector2);
}
extern "C" {
    pub fn godot_pool_vector2_array_remove(p_self:
                                           *mut godot_pool_vector2_array,
                                           p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_vector2_array_resize(p_self:
                                           *mut godot_pool_vector2_array,
                                           p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_vector2_array_set(p_self: *mut godot_pool_vector2_array,
                                        p_idx: godot_int,
                                        p_data: *const godot_vector2);
}
extern "C" {
    pub fn godot_pool_vector2_array_get(p_self:
                                        *const godot_pool_vector2_array,
                                        p_idx: godot_int) -> godot_vector2;
}
extern "C" {
    pub fn godot_pool_vector2_array_size(p_self:
                                         *const godot_pool_vector2_array)
                                         -> godot_int;
}
extern "C" {
    pub fn godot_pool_vector2_array_destroy(p_self:
                                            *mut godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_new(r_dest:
                                        *mut godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_new_copy(r_dest:
                                             *mut godot_pool_vector3_array,
                                             p_src:
                                             *const godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_new_with_array(r_dest:
                                                   *mut godot_pool_vector3_array,
                                                   p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_append(p_self:
                                           *mut godot_pool_vector3_array,
                                           p_data: *const godot_vector3);
}
extern "C" {
    pub fn godot_pool_vector3_array_append_array(p_self:
                                                 *mut godot_pool_vector3_array,
                                                 p_array:
                                                 *const godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_insert(p_self:
                                           *mut godot_pool_vector3_array,
                                           p_idx: godot_int,
                                           p_data: *const godot_vector3)
                                           -> godot_error;
}
extern "C" {
    pub fn godot_pool_vector3_array_invert(p_self:
                                           *mut godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_vector3_array_push_back(p_self:
                                              *mut godot_pool_vector3_array,
                                              p_data: *const godot_vector3);
}
extern "C" {
    pub fn godot_pool_vector3_array_remove(p_self:
                                           *mut godot_pool_vector3_array,
                                           p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_vector3_array_resize(p_self:
                                           *mut godot_pool_vector3_array,
                                           p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_vector3_array_set(p_self: *mut godot_pool_vector3_array,
                                        p_idx: godot_int,
                                        p_data: *const godot_vector3);
}
extern "C" {
    pub fn godot_pool_vector3_array_get(p_self:
                                        *const godot_pool_vector3_array,
                                        p_idx: godot_int) -> godot_vector3;
}
extern "C" {
    pub fn godot_pool_vector3_array_size(p_self:
                                         *const godot_pool_vector3_array)
                                         -> godot_int;
}
extern "C" {
    pub fn godot_pool_vector3_array_destroy(p_self:
                                            *mut godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_pool_color_array_new(r_dest: *mut godot_pool_color_array);
}
extern "C" {
    pub fn godot_pool_color_array_new_copy(r_dest:
                                           *mut godot_pool_color_array,
                                           p_src:
                                           *const godot_pool_color_array);
}
extern "C" {
    pub fn godot_pool_color_array_new_with_array(r_dest:
                                                 *mut godot_pool_color_array,
                                                 p_a: *const godot_array);
}
extern "C" {
    pub fn godot_pool_color_array_append(p_self: *mut godot_pool_color_array,
                                         p_data: *const godot_color);
}
extern "C" {
    pub fn godot_pool_color_array_append_array(p_self:
                                               *mut godot_pool_color_array,
                                               p_array:
                                               *const godot_pool_color_array);
}
extern "C" {
    pub fn godot_pool_color_array_insert(p_self: *mut godot_pool_color_array,
                                         p_idx: godot_int,
                                         p_data: *const godot_color)
                                         -> godot_error;
}
extern "C" {
    pub fn godot_pool_color_array_invert(p_self: *mut godot_pool_color_array);
}
extern "C" {
    pub fn godot_pool_color_array_push_back(p_self:
                                            *mut godot_pool_color_array,
                                            p_data: *const godot_color);
}
extern "C" {
    pub fn godot_pool_color_array_remove(p_self: *mut godot_pool_color_array,
                                         p_idx: godot_int);
}
extern "C" {
    pub fn godot_pool_color_array_resize(p_self: *mut godot_pool_color_array,
                                         p_size: godot_int);
}
extern "C" {
    pub fn godot_pool_color_array_set(p_self: *mut godot_pool_color_array,
                                      p_idx: godot_int,
                                      p_data: *const godot_color);
}
extern "C" {
    pub fn godot_pool_color_array_get(p_self: *const godot_pool_color_array,
                                      p_idx: godot_int) -> godot_color;
}
extern "C" {
    pub fn godot_pool_color_array_size(p_self: *const godot_pool_color_array)
                                       -> godot_int;
}
extern "C" {
    pub fn godot_pool_color_array_destroy(p_self:
                                          *mut godot_pool_color_array);
}
extern "C" {
    pub fn godot_array_new(r_dest: *mut godot_array);
}
extern "C" {
    pub fn godot_array_new_copy(r_dest: *mut godot_array,
                                p_src: *const godot_array);
}
extern "C" {
    pub fn godot_array_new_pool_color_array(r_dest: *mut godot_array,
                                            p_pca:
                                            *const godot_pool_color_array);
}
extern "C" {
    pub fn godot_array_new_pool_vector3_array(r_dest: *mut godot_array,
                                              p_pv3a:
                                              *const godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_array_new_pool_vector2_array(r_dest: *mut godot_array,
                                              p_pv2a:
                                              *const godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_array_new_pool_string_array(r_dest: *mut godot_array,
                                             p_psa:
                                             *const godot_pool_string_array);
}
extern "C" {
    pub fn godot_array_new_pool_real_array(r_dest: *mut godot_array,
                                           p_pra:
                                           *const godot_pool_real_array);
}
extern "C" {
    pub fn godot_array_new_pool_int_array(r_dest: *mut godot_array,
                                          p_pia: *const godot_pool_int_array);
}
extern "C" {
    pub fn godot_array_new_pool_byte_array(r_dest: *mut godot_array,
                                           p_pba:
                                           *const godot_pool_byte_array);
}
extern "C" {
    pub fn godot_array_set(p_self: *mut godot_array, p_idx: godot_int,
                           p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_get(p_self: *const godot_array, p_idx: godot_int)
                           -> godot_variant;
}
extern "C" {
    pub fn godot_array_operator_index(p_self: *mut godot_array,
                                      p_idx: godot_int) -> *mut godot_variant;
}
extern "C" {
    pub fn godot_array_append(p_self: *mut godot_array,
                              p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_clear(p_self: *mut godot_array);
}
extern "C" {
    pub fn godot_array_count(p_self: *const godot_array,
                             p_value: *const godot_variant) -> godot_int;
}
extern "C" {
    pub fn godot_array_empty(p_self: *const godot_array) -> godot_bool;
}
extern "C" {
    pub fn godot_array_erase(p_self: *mut godot_array,
                             p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_front(p_self: *const godot_array) -> godot_variant;
}
extern "C" {
    pub fn godot_array_back(p_self: *const godot_array) -> godot_variant;
}
extern "C" {
    pub fn godot_array_find(p_self: *const godot_array,
                            p_what: *const godot_variant, p_from: godot_int)
                            -> godot_int;
}
extern "C" {
    pub fn godot_array_find_last(p_self: *const godot_array,
                                 p_what: *const godot_variant) -> godot_int;
}
extern "C" {
    pub fn godot_array_has(p_self: *const godot_array,
                           p_value: *const godot_variant) -> godot_bool;
}
extern "C" {
    pub fn godot_array_hash(p_self: *const godot_array) -> godot_int;
}
extern "C" {
    pub fn godot_array_insert(p_self: *mut godot_array, p_pos: godot_int,
                              p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_invert(p_self: *mut godot_array);
}
extern "C" {
    pub fn godot_array_pop_back(p_self: *mut godot_array) -> godot_variant;
}
extern "C" {
    pub fn godot_array_pop_front(p_self: *mut godot_array) -> godot_variant;
}
extern "C" {
    pub fn godot_array_push_back(p_self: *mut godot_array,
                                 p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_push_front(p_self: *mut godot_array,
                                  p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_array_remove(p_self: *mut godot_array, p_idx: godot_int);
}
extern "C" {
    pub fn godot_array_resize(p_self: *mut godot_array, p_size: godot_int);
}
extern "C" {
    pub fn godot_array_rfind(p_self: *const godot_array,
                             p_what: *const godot_variant, p_from: godot_int)
                             -> godot_int;
}
extern "C" {
    pub fn godot_array_size(p_self: *const godot_array) -> godot_int;
}
extern "C" {
    pub fn godot_array_sort(p_self: *mut godot_array);
}
extern "C" {
    pub fn godot_array_sort_custom(p_self: *mut godot_array,
                                   p_obj: *mut godot_object,
                                   p_func: *const godot_string);
}
extern "C" {
    pub fn godot_array_destroy(p_self: *mut godot_array);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_dictionary {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_dictionary() {
    assert_eq!(::std::mem::size_of::<godot_dictionary>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_dictionary ) ));
    assert_eq! (::std::mem::align_of::<godot_dictionary>() , 1usize , concat !
    ( "Alignment of " , stringify ! ( godot_dictionary ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_dictionary ) ) . _dont_touch_that
            as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_dictionary ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_dictionary {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_dictionary_new(r_dest: *mut godot_dictionary);
}
extern "C" {
    pub fn godot_dictionary_new_copy(r_dest: *mut godot_dictionary,
                                     p_src: *const godot_dictionary);
}
extern "C" {
    pub fn godot_dictionary_destroy(p_self: *mut godot_dictionary);
}
extern "C" {
    pub fn godot_dictionary_size(p_self: *const godot_dictionary)
                                 -> godot_int;
}
extern "C" {
    pub fn godot_dictionary_empty(p_self: *const godot_dictionary)
                                  -> godot_bool;
}
extern "C" {
    pub fn godot_dictionary_clear(p_self: *mut godot_dictionary);
}
extern "C" {
    pub fn godot_dictionary_has(p_self: *const godot_dictionary,
                                p_key: *const godot_variant) -> godot_bool;
}
extern "C" {
    pub fn godot_dictionary_has_all(p_self: *const godot_dictionary,
                                    p_keys: *const godot_array) -> godot_bool;
}
extern "C" {
    pub fn godot_dictionary_erase(p_self: *mut godot_dictionary,
                                  p_key: *const godot_variant);
}
extern "C" {
    pub fn godot_dictionary_hash(p_self: *const godot_dictionary)
                                 -> godot_int;
}
extern "C" {
    pub fn godot_dictionary_keys(p_self: *const godot_dictionary)
                                 -> godot_array;
}
extern "C" {
    pub fn godot_dictionary_values(p_self: *const godot_dictionary)
                                   -> godot_array;
}
extern "C" {
    pub fn godot_dictionary_get(p_self: *const godot_dictionary,
                                p_key: *const godot_variant) -> godot_variant;
}
extern "C" {
    pub fn godot_dictionary_set(p_self: *mut godot_dictionary,
                                p_key: *const godot_variant,
                                p_value: *const godot_variant);
}
extern "C" {
    pub fn godot_dictionary_operator_index(p_self: *mut godot_dictionary,
                                           p_key: *const godot_variant)
                                           -> *mut godot_variant;
}
extern "C" {
    pub fn godot_dictionary_next(p_self: *const godot_dictionary,
                                 p_key: *const godot_variant)
                                 -> *mut godot_variant;
}
extern "C" {
    pub fn godot_dictionary_operator_equal(p_self: *const godot_dictionary,
                                           p_b: *const godot_dictionary)
                                           -> godot_bool;
}
extern "C" {
    pub fn godot_dictionary_to_json(p_self: *const godot_dictionary)
                                    -> godot_string;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_node_path {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_node_path() {
    assert_eq!(::std::mem::size_of::<godot_node_path>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_node_path ) ));
    assert_eq! (::std::mem::align_of::<godot_node_path>() , 1usize , concat !
    ( "Alignment of " , stringify ! ( godot_node_path ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_node_path ) ) . _dont_touch_that as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_node_path ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_node_path {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_node_path_new(r_dest: *mut godot_node_path,
                               p_from: *const godot_string);
}
extern "C" {
    pub fn godot_node_path_new_copy(r_dest: *mut godot_node_path,
                                    p_src: *const godot_node_path);
}
extern "C" {
    pub fn godot_node_path_destroy(p_self: *mut godot_node_path);
}
extern "C" {
    pub fn godot_node_path_as_string(p_self: *const godot_node_path)
                                     -> godot_string;
}
extern "C" {
    pub fn godot_node_path_is_absolute(p_self: *const godot_node_path)
                                       -> godot_bool;
}
extern "C" {
    pub fn godot_node_path_get_name_count(p_self: *const godot_node_path)
                                          -> godot_int;
}
extern "C" {
    pub fn godot_node_path_get_name(p_self: *const godot_node_path,
                                    p_idx: godot_int) -> godot_string;
}
extern "C" {
    pub fn godot_node_path_get_subname_count(p_self: *const godot_node_path)
                                             -> godot_int;
}
extern "C" {
    pub fn godot_node_path_get_subname(p_self: *const godot_node_path,
                                       p_idx: godot_int) -> godot_string;
}
extern "C" {
    pub fn godot_node_path_get_property(p_self: *const godot_node_path)
                                        -> godot_string;
}
extern "C" {
    pub fn godot_node_path_is_empty(p_self: *const godot_node_path)
                                    -> godot_bool;
}
extern "C" {
    pub fn godot_node_path_operator_equal(p_self: *const godot_node_path,
                                          p_b: *const godot_node_path)
                                          -> godot_bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_plane {
    pub _dont_touch_that: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_godot_plane() {
    assert_eq!(::std::mem::size_of::<godot_plane>() , 16usize , concat ! (
               "Size of: " , stringify ! ( godot_plane ) ));
    assert_eq! (::std::mem::align_of::<godot_plane>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_plane ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_plane ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_plane ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_plane {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_plane_new_with_reals(r_dest: *mut godot_plane,
                                      p_a: godot_real, p_b: godot_real,
                                      p_c: godot_real, p_d: godot_real);
}
extern "C" {
    pub fn godot_plane_new_with_vectors(r_dest: *mut godot_plane,
                                        p_v1: *const godot_vector3,
                                        p_v2: *const godot_vector3,
                                        p_v3: *const godot_vector3);
}
extern "C" {
    pub fn godot_plane_new_with_normal(r_dest: *mut godot_plane,
                                       p_normal: *const godot_vector3,
                                       p_d: godot_real);
}
extern "C" {
    pub fn godot_plane_as_string(p_self: *const godot_plane) -> godot_string;
}
extern "C" {
    pub fn godot_plane_normalized(p_self: *const godot_plane) -> godot_plane;
}
extern "C" {
    pub fn godot_plane_center(p_self: *const godot_plane) -> godot_vector3;
}
extern "C" {
    pub fn godot_plane_get_any_point(p_self: *const godot_plane)
                                     -> godot_vector3;
}
extern "C" {
    pub fn godot_plane_is_point_over(p_self: *const godot_plane,
                                     p_point: *const godot_vector3)
                                     -> godot_bool;
}
extern "C" {
    pub fn godot_plane_distance_to(p_self: *const godot_plane,
                                   p_point: *const godot_vector3)
                                   -> godot_real;
}
extern "C" {
    pub fn godot_plane_has_point(p_self: *const godot_plane,
                                 p_point: *const godot_vector3,
                                 p_epsilon: godot_real) -> godot_bool;
}
extern "C" {
    pub fn godot_plane_project(p_self: *const godot_plane,
                               p_point: *const godot_vector3)
                               -> godot_vector3;
}
extern "C" {
    pub fn godot_plane_intersect_3(p_self: *const godot_plane,
                                   r_dest: *mut godot_vector3,
                                   p_b: *const godot_plane,
                                   p_c: *const godot_plane) -> godot_bool;
}
extern "C" {
    pub fn godot_plane_intersects_ray(p_self: *const godot_plane,
                                      r_dest: *mut godot_vector3,
                                      p_from: *const godot_vector3,
                                      p_dir: *const godot_vector3)
                                      -> godot_bool;
}
extern "C" {
    pub fn godot_plane_intersects_segment(p_self: *const godot_plane,
                                          r_dest: *mut godot_vector3,
                                          p_begin: *const godot_vector3,
                                          p_end: *const godot_vector3)
                                          -> godot_bool;
}
extern "C" {
    pub fn godot_plane_operator_neg(p_self: *const godot_plane)
                                    -> godot_plane;
}
extern "C" {
    pub fn godot_plane_operator_equal(p_self: *const godot_plane,
                                      p_b: *const godot_plane) -> godot_bool;
}
extern "C" {
    pub fn godot_plane_set_normal(p_self: *mut godot_plane,
                                  p_normal: *const godot_vector3);
}
extern "C" {
    pub fn godot_plane_get_normal(p_self: *const godot_plane)
                                  -> godot_vector3;
}
extern "C" {
    pub fn godot_plane_get_d(p_self: *const godot_plane) -> godot_real;
}
extern "C" {
    pub fn godot_plane_set_d(p_self: *mut godot_plane, p_d: godot_real);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_rect3 {
    pub _dont_touch_that: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_godot_rect3() {
    assert_eq!(::std::mem::size_of::<godot_rect3>() , 24usize , concat ! (
               "Size of: " , stringify ! ( godot_rect3 ) ));
    assert_eq! (::std::mem::align_of::<godot_rect3>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_rect3 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_rect3 ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_rect3 ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_rect3 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_rect3_new(r_dest: *mut godot_rect3,
                           p_pos: *const godot_vector3,
                           p_size: *const godot_vector3);
}
extern "C" {
    pub fn godot_rect3_get_position(p_self: *const godot_rect3)
                                    -> godot_vector3;
}
extern "C" {
    pub fn godot_rect3_set_position(p_self: *const godot_rect3,
                                    p_v: *const godot_vector3);
}
extern "C" {
    pub fn godot_rect3_get_size(p_self: *const godot_rect3) -> godot_vector3;
}
extern "C" {
    pub fn godot_rect3_set_size(p_self: *const godot_rect3,
                                p_v: *const godot_vector3);
}
extern "C" {
    pub fn godot_rect3_as_string(p_self: *const godot_rect3) -> godot_string;
}
extern "C" {
    pub fn godot_rect3_get_area(p_self: *const godot_rect3) -> godot_real;
}
extern "C" {
    pub fn godot_rect3_has_no_area(p_self: *const godot_rect3) -> godot_bool;
}
extern "C" {
    pub fn godot_rect3_has_no_surface(p_self: *const godot_rect3)
                                      -> godot_bool;
}
extern "C" {
    pub fn godot_rect3_intersects(p_self: *const godot_rect3,
                                  p_with: *const godot_rect3) -> godot_bool;
}
extern "C" {
    pub fn godot_rect3_encloses(p_self: *const godot_rect3,
                                p_with: *const godot_rect3) -> godot_bool;
}
extern "C" {
    pub fn godot_rect3_merge(p_self: *const godot_rect3,
                             p_with: *const godot_rect3) -> godot_rect3;
}
extern "C" {
    pub fn godot_rect3_intersection(p_self: *const godot_rect3,
                                    p_with: *const godot_rect3)
                                    -> godot_rect3;
}
extern "C" {
    pub fn godot_rect3_intersects_plane(p_self: *const godot_rect3,
                                        p_plane: *const godot_plane)
                                        -> godot_bool;
}
extern "C" {
    pub fn godot_rect3_intersects_segment(p_self: *const godot_rect3,
                                          p_from: *const godot_vector3,
                                          p_to: *const godot_vector3)
                                          -> godot_bool;
}
extern "C" {
    pub fn godot_rect3_has_point(p_self: *const godot_rect3,
                                 p_point: *const godot_vector3) -> godot_bool;
}
extern "C" {
    pub fn godot_rect3_get_support(p_self: *const godot_rect3,
                                   p_dir: *const godot_vector3)
                                   -> godot_vector3;
}
extern "C" {
    pub fn godot_rect3_get_longest_axis(p_self: *const godot_rect3)
                                        -> godot_vector3;
}
extern "C" {
    pub fn godot_rect3_get_longest_axis_index(p_self: *const godot_rect3)
                                              -> godot_int;
}
extern "C" {
    pub fn godot_rect3_get_longest_axis_size(p_self: *const godot_rect3)
                                             -> godot_real;
}
extern "C" {
    pub fn godot_rect3_get_shortest_axis(p_self: *const godot_rect3)
                                         -> godot_vector3;
}
extern "C" {
    pub fn godot_rect3_get_shortest_axis_index(p_self: *const godot_rect3)
                                               -> godot_int;
}
extern "C" {
    pub fn godot_rect3_get_shortest_axis_size(p_self: *const godot_rect3)
                                              -> godot_real;
}
extern "C" {
    pub fn godot_rect3_expand(p_self: *const godot_rect3,
                              p_to_point: *const godot_vector3)
                              -> godot_rect3;
}
extern "C" {
    pub fn godot_rect3_grow(p_self: *const godot_rect3, p_by: godot_real)
                            -> godot_rect3;
}
extern "C" {
    pub fn godot_rect3_get_endpoint(p_self: *const godot_rect3,
                                    p_idx: godot_int) -> godot_vector3;
}
extern "C" {
    pub fn godot_rect3_operator_equal(p_self: *const godot_rect3,
                                      p_b: *const godot_rect3) -> godot_bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_rid {
    pub _dont_touch_that: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_godot_rid() {
    assert_eq!(::std::mem::size_of::<godot_rid>() , 8usize , concat ! (
               "Size of: " , stringify ! ( godot_rid ) ));
    assert_eq! (::std::mem::align_of::<godot_rid>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( godot_rid ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_rid ) ) . _dont_touch_that as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_rid ) , "::" ,
                stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_rid {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_rid_new(r_dest: *mut godot_rid);
}
extern "C" {
    pub fn godot_rid_get_id(p_self: *const godot_rid) -> godot_int;
}
extern "C" {
    pub fn godot_rid_new_with_resource(r_dest: *mut godot_rid,
                                       p_from: *const godot_object);
}
extern "C" {
    pub fn godot_rid_operator_equal(p_self: *const godot_rid,
                                    p_b: *const godot_rid) -> godot_bool;
}
extern "C" {
    pub fn godot_rid_operator_less(p_self: *const godot_rid,
                                   p_b: *const godot_rid) -> godot_bool;
}
#[repr(C)]
pub struct godot_transform {
    pub _dont_touch_that: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_godot_transform() {
    assert_eq!(::std::mem::size_of::<godot_transform>() , 48usize , concat ! (
               "Size of: " , stringify ! ( godot_transform ) ));
    assert_eq! (::std::mem::align_of::<godot_transform>() , 1usize , concat !
    ( "Alignment of " , stringify ! ( godot_transform ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_transform ) ) . _dont_touch_that as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_transform ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
extern "C" {
    pub fn godot_transform_new_with_axis_origin(r_dest: *mut godot_transform,
                                                p_x_axis:
                                                *const godot_vector3,
                                                p_y_axis:
                                                *const godot_vector3,
                                                p_z_axis:
                                                *const godot_vector3,
                                                p_origin:
                                                *const godot_vector3);
}
extern "C" {
    pub fn godot_transform_new(r_dest: *mut godot_transform,
                               p_basis: *const godot_basis,
                               p_origin: *const godot_vector3);
}
extern "C" {
    pub fn godot_transform_get_basis(p_self: *const godot_transform)
                                     -> godot_basis;
}
extern "C" {
    pub fn godot_transform_set_basis(p_self: *mut godot_transform,
                                     p_v: *mut godot_basis);
}
extern "C" {
    pub fn godot_transform_get_origin(p_self: *const godot_transform)
                                      -> godot_vector3;
}
extern "C" {
    pub fn godot_transform_set_origin(p_self: *mut godot_transform,
                                      p_v: *mut godot_vector3);
}
extern "C" {
    pub fn godot_transform_as_string(p_self: *const godot_transform)
                                     -> godot_string;
}
extern "C" {
    pub fn godot_transform_inverse(p_self: *const godot_transform)
                                   -> godot_transform;
}
extern "C" {
    pub fn godot_transform_affine_inverse(p_self: *const godot_transform)
                                          -> godot_transform;
}
extern "C" {
    pub fn godot_transform_orthonormalized(p_self: *const godot_transform)
                                           -> godot_transform;
}
extern "C" {
    pub fn godot_transform_rotated(p_self: *const godot_transform,
                                   p_axis: *const godot_vector3,
                                   p_phi: godot_real) -> godot_transform;
}
extern "C" {
    pub fn godot_transform_scaled(p_self: *const godot_transform,
                                  p_scale: *const godot_vector3)
                                  -> godot_transform;
}
extern "C" {
    pub fn godot_transform_translated(p_self: *const godot_transform,
                                      p_ofs: *const godot_vector3)
                                      -> godot_transform;
}
extern "C" {
    pub fn godot_transform_looking_at(p_self: *const godot_transform,
                                      p_target: *const godot_vector3,
                                      p_up: *const godot_vector3)
                                      -> godot_transform;
}
extern "C" {
    pub fn godot_transform_xform_plane(p_self: *const godot_transform,
                                       p_v: *const godot_plane)
                                       -> godot_plane;
}
extern "C" {
    pub fn godot_transform_xform_inv_plane(p_self: *const godot_transform,
                                           p_v: *const godot_plane)
                                           -> godot_plane;
}
extern "C" {
    pub fn godot_transform_new_identity(r_dest: *mut godot_transform);
}
extern "C" {
    pub fn godot_transform_operator_equal(p_self: *const godot_transform,
                                          p_b: *const godot_transform)
                                          -> godot_bool;
}
extern "C" {
    pub fn godot_transform_operator_multiply(p_self: *const godot_transform,
                                             p_b: *const godot_transform)
                                             -> godot_transform;
}
extern "C" {
    pub fn godot_transform_xform_vector3(p_self: *const godot_transform,
                                         p_v: *const godot_vector3)
                                         -> godot_vector3;
}
extern "C" {
    pub fn godot_transform_xform_inv_vector3(p_self: *const godot_transform,
                                             p_v: *const godot_vector3)
                                             -> godot_vector3;
}
extern "C" {
    pub fn godot_transform_xform_rect3(p_self: *const godot_transform,
                                       p_v: *const godot_rect3)
                                       -> godot_rect3;
}
extern "C" {
    pub fn godot_transform_xform_inv_rect3(p_self: *const godot_transform,
                                           p_v: *const godot_rect3)
                                           -> godot_rect3;
}
extern "C" {
    pub fn godot_variant_get_type(p_v: *const godot_variant)
                                  -> godot_variant_type;
}
extern "C" {
    pub fn godot_variant_new_copy(r_dest: *mut godot_variant,
                                  p_src: *const godot_variant);
}
extern "C" {
    pub fn godot_variant_new_nil(r_dest: *mut godot_variant);
}
extern "C" {
    pub fn godot_variant_new_bool(p_v: *mut godot_variant, p_b: godot_bool);
}
extern "C" {
    pub fn godot_variant_new_uint(r_dest: *mut godot_variant, p_i: u64);
}
extern "C" {
    pub fn godot_variant_new_int(r_dest: *mut godot_variant, p_i: i64);
}
extern "C" {
    pub fn godot_variant_new_real(r_dest: *mut godot_variant, p_r: f64);
}
extern "C" {
    pub fn godot_variant_new_string(r_dest: *mut godot_variant,
                                    p_s: *const godot_string);
}
extern "C" {
    pub fn godot_variant_new_vector2(r_dest: *mut godot_variant,
                                     p_v2: *const godot_vector2);
}
extern "C" {
    pub fn godot_variant_new_rect2(r_dest: *mut godot_variant,
                                   p_rect2: *const godot_rect2);
}
extern "C" {
    pub fn godot_variant_new_vector3(r_dest: *mut godot_variant,
                                     p_v3: *const godot_vector3);
}
extern "C" {
    pub fn godot_variant_new_transform2d(r_dest: *mut godot_variant,
                                         p_t2d: *const godot_transform2d);
}
extern "C" {
    pub fn godot_variant_new_plane(r_dest: *mut godot_variant,
                                   p_plane: *const godot_plane);
}
extern "C" {
    pub fn godot_variant_new_quat(r_dest: *mut godot_variant,
                                  p_quat: *const godot_quat);
}
extern "C" {
    pub fn godot_variant_new_rect3(r_dest: *mut godot_variant,
                                   p_rect3: *const godot_rect3);
}
extern "C" {
    pub fn godot_variant_new_basis(r_dest: *mut godot_variant,
                                   p_basis: *const godot_basis);
}
extern "C" {
    pub fn godot_variant_new_transform(r_dest: *mut godot_variant,
                                       p_trans: *const godot_transform);
}
extern "C" {
    pub fn godot_variant_new_color(r_dest: *mut godot_variant,
                                   p_color: *const godot_color);
}
extern "C" {
    pub fn godot_variant_new_node_path(r_dest: *mut godot_variant,
                                       p_np: *const godot_node_path);
}
extern "C" {
    pub fn godot_variant_new_rid(r_dest: *mut godot_variant,
                                 p_rid: *const godot_rid);
}
extern "C" {
    pub fn godot_variant_new_object(r_dest: *mut godot_variant,
                                    p_obj: *const godot_object);
}
extern "C" {
    pub fn godot_variant_new_dictionary(r_dest: *mut godot_variant,
                                        p_dict: *const godot_dictionary);
}
extern "C" {
    pub fn godot_variant_new_array(r_dest: *mut godot_variant,
                                   p_arr: *const godot_array);
}
extern "C" {
    pub fn godot_variant_new_pool_byte_array(r_dest: *mut godot_variant,
                                             p_pba:
                                             *const godot_pool_byte_array);
}
extern "C" {
    pub fn godot_variant_new_pool_int_array(r_dest: *mut godot_variant,
                                            p_pia:
                                            *const godot_pool_int_array);
}
extern "C" {
    pub fn godot_variant_new_pool_real_array(r_dest: *mut godot_variant,
                                             p_pra:
                                             *const godot_pool_real_array);
}
extern "C" {
    pub fn godot_variant_new_pool_string_array(r_dest: *mut godot_variant,
                                               p_psa:
                                               *const godot_pool_string_array);
}
extern "C" {
    pub fn godot_variant_new_pool_vector2_array(r_dest: *mut godot_variant,
                                                p_pv2a:
                                                *const godot_pool_vector2_array);
}
extern "C" {
    pub fn godot_variant_new_pool_vector3_array(r_dest: *mut godot_variant,
                                                p_pv3a:
                                                *const godot_pool_vector3_array);
}
extern "C" {
    pub fn godot_variant_new_pool_color_array(r_dest: *mut godot_variant,
                                              p_pca:
                                              *const godot_pool_color_array);
}
extern "C" {
    pub fn godot_variant_as_bool(p_self: *const godot_variant) -> godot_bool;
}
extern "C" {
    pub fn godot_variant_as_uint(p_self: *const godot_variant) -> u64;
}
extern "C" {
    pub fn godot_variant_as_int(p_self: *const godot_variant) -> i64;
}
extern "C" {
    pub fn godot_variant_as_real(p_self: *const godot_variant) -> f64;
}
extern "C" {
    pub fn godot_variant_as_string(p_self: *const godot_variant)
                                   -> godot_string;
}
extern "C" {
    pub fn godot_variant_as_vector2(p_self: *const godot_variant)
                                    -> godot_vector2;
}
extern "C" {
    pub fn godot_variant_as_rect2(p_self: *const godot_variant)
                                  -> godot_rect2;
}
extern "C" {
    pub fn godot_variant_as_vector3(p_self: *const godot_variant)
                                    -> godot_vector3;
}
extern "C" {
    pub fn godot_variant_as_transform2d(p_self: *const godot_variant)
                                        -> godot_transform2d;
}
extern "C" {
    pub fn godot_variant_as_plane(p_self: *const godot_variant)
                                  -> godot_plane;
}
extern "C" {
    pub fn godot_variant_as_quat(p_self: *const godot_variant) -> godot_quat;
}
extern "C" {
    pub fn godot_variant_as_rect3(p_self: *const godot_variant)
                                  -> godot_rect3;
}
extern "C" {
    pub fn godot_variant_as_basis(p_self: *const godot_variant)
                                  -> godot_basis;
}
extern "C" {
    pub fn godot_variant_as_transform(p_self: *const godot_variant)
                                      -> godot_transform;
}
extern "C" {
    pub fn godot_variant_as_color(p_self: *const godot_variant)
                                  -> godot_color;
}
extern "C" {
    pub fn godot_variant_as_node_path(p_self: *const godot_variant)
                                      -> godot_node_path;
}
extern "C" {
    pub fn godot_variant_as_rid(p_self: *const godot_variant) -> godot_rid;
}
extern "C" {
    pub fn godot_variant_as_object(p_self: *const godot_variant)
                                   -> *mut godot_object;
}
extern "C" {
    pub fn godot_variant_as_dictionary(p_self: *const godot_variant)
                                       -> godot_dictionary;
}
extern "C" {
    pub fn godot_variant_as_array(p_self: *const godot_variant)
                                  -> godot_array;
}
extern "C" {
    pub fn godot_variant_as_pool_byte_array(p_self: *const godot_variant)
                                            -> godot_pool_byte_array;
}
extern "C" {
    pub fn godot_variant_as_pool_int_array(p_self: *const godot_variant)
                                           -> godot_pool_int_array;
}
extern "C" {
    pub fn godot_variant_as_pool_real_array(p_self: *const godot_variant)
                                            -> godot_pool_real_array;
}
extern "C" {
    pub fn godot_variant_as_pool_string_array(p_self: *const godot_variant)
                                              -> godot_pool_string_array;
}
extern "C" {
    pub fn godot_variant_as_pool_vector2_array(p_self: *const godot_variant)
                                               -> godot_pool_vector2_array;
}
extern "C" {
    pub fn godot_variant_as_pool_vector3_array(p_self: *const godot_variant)
                                               -> godot_pool_vector3_array;
}
extern "C" {
    pub fn godot_variant_as_pool_color_array(p_self: *const godot_variant)
                                             -> godot_pool_color_array;
}
extern "C" {
    pub fn godot_variant_call(p_self: *mut godot_variant,
                              p_method: *const godot_string,
                              p_args: *mut *const godot_variant,
                              p_argcount: godot_int,
                              r_error: *mut godot_variant_call_error)
                              -> godot_variant;
}
extern "C" {
    pub fn godot_variant_has_method(p_self: *const godot_variant,
                                    p_method: *const godot_string)
                                    -> godot_bool;
}
extern "C" {
    pub fn godot_variant_operator_equal(p_self: *const godot_variant,
                                        p_other: *const godot_variant)
                                        -> godot_bool;
}
extern "C" {
    pub fn godot_variant_operator_less(p_self: *const godot_variant,
                                       p_other: *const godot_variant)
                                       -> godot_bool;
}
extern "C" {
    pub fn godot_variant_hash_compare(p_self: *const godot_variant,
                                      p_other: *const godot_variant)
                                      -> godot_bool;
}
extern "C" {
    pub fn godot_variant_booleanize(p_self: *const godot_variant,
                                    r_valid: *mut godot_bool) -> godot_bool;
}
extern "C" {
    pub fn godot_variant_destroy(p_self: *mut godot_variant);
}
extern "C" {
    pub fn godot_transform2d_new(r_dest: *mut godot_transform2d,
                                 p_rot: godot_real,
                                 p_pos: *const godot_vector2);
}
extern "C" {
    pub fn godot_transform2d_new_axis_origin(r_dest: *mut godot_transform2d,
                                             p_x_axis: *const godot_vector2,
                                             p_y_axis: *const godot_vector2,
                                             p_origin: *const godot_vector2);
}
extern "C" {
    pub fn godot_transform2d_as_string(p_self: *const godot_transform2d)
                                       -> godot_string;
}
extern "C" {
    pub fn godot_transform2d_inverse(p_self: *const godot_transform2d)
                                     -> godot_transform2d;
}
extern "C" {
    pub fn godot_transform2d_affine_inverse(p_self: *const godot_transform2d)
                                            -> godot_transform2d;
}
extern "C" {
    pub fn godot_transform2d_get_rotation(p_self: *const godot_transform2d)
                                          -> godot_real;
}
extern "C" {
    pub fn godot_transform2d_get_origin(p_self: *const godot_transform2d)
                                        -> godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_get_scale(p_self: *const godot_transform2d)
                                       -> godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_orthonormalized(p_self: *const godot_transform2d)
                                             -> godot_transform2d;
}
extern "C" {
    pub fn godot_transform2d_rotated(p_self: *const godot_transform2d,
                                     p_phi: godot_real) -> godot_transform2d;
}
extern "C" {
    pub fn godot_transform2d_scaled(p_self: *const godot_transform2d,
                                    p_scale: *const godot_vector2)
                                    -> godot_transform2d;
}
extern "C" {
    pub fn godot_transform2d_translated(p_self: *const godot_transform2d,
                                        p_offset: *const godot_vector2)
                                        -> godot_transform2d;
}
extern "C" {
    pub fn godot_transform2d_xform_vector2(p_self: *const godot_transform2d,
                                           p_v: *const godot_vector2)
                                           -> godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_xform_inv_vector2(p_self:
                                               *const godot_transform2d,
                                               p_v: *const godot_vector2)
                                               -> godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_basis_xform_vector2(p_self:
                                                 *const godot_transform2d,
                                                 p_v: *const godot_vector2)
                                                 -> godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_basis_xform_inv_vector2(p_self:
                                                     *const godot_transform2d,
                                                     p_v:
                                                     *const godot_vector2)
                                                     -> godot_vector2;
}
extern "C" {
    pub fn godot_transform2d_interpolate_with(p_self:
                                              *const godot_transform2d,
                                              p_m: *const godot_transform2d,
                                              p_c: godot_real)
                                              -> godot_transform2d;
}
extern "C" {
    pub fn godot_transform2d_operator_equal(p_self: *const godot_transform2d,
                                            p_b: *const godot_transform2d)
                                            -> godot_bool;
}
extern "C" {
    pub fn godot_transform2d_operator_multiply(p_self:
                                               *const godot_transform2d,
                                               p_b: *const godot_transform2d)
                                               -> godot_transform2d;
}
extern "C" {
    pub fn godot_transform2d_new_identity(r_dest: *mut godot_transform2d);
}
extern "C" {
    pub fn godot_transform2d_xform_rect2(p_self: *const godot_transform2d,
                                         p_v: *const godot_rect2)
                                         -> godot_rect2;
}
extern "C" {
    pub fn godot_transform2d_xform_inv_rect2(p_self: *const godot_transform2d,
                                             p_v: *const godot_rect2)
                                             -> godot_rect2;
}
extern "C" {
    pub fn godot_object_destroy(p_o: *mut godot_object);
}
extern "C" {
    ////// Singleton API
    pub fn godot_global_get_singleton(p_name: *mut ::std::os::raw::c_char)
                                      -> *mut godot_object;
}
////// MethodBind API
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_method_bind {
    pub _dont_touch_that: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_godot_method_bind() {
    assert_eq!(::std::mem::size_of::<godot_method_bind>() , 1usize , concat !
    ( "Size of: " , stringify ! ( godot_method_bind ) ));
    assert_eq! (::std::mem::align_of::<godot_method_bind>() , 1usize , concat
    ! ( "Alignment of " , stringify ! ( godot_method_bind ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_method_bind ) ) . _dont_touch_that
            as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_method_bind ) ,
                "::" , stringify ! ( _dont_touch_that ) ));
}
impl Clone for godot_method_bind {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_method_bind_get_method(p_classname:
                                        *const ::std::os::raw::c_char,
                                        p_methodname:
                                        *const ::std::os::raw::c_char)
                                        -> *mut godot_method_bind;
}
extern "C" {
    pub fn godot_method_bind_ptrcall(p_method_bind: *mut godot_method_bind,
                                     p_instance: *mut godot_object,
                                     p_args:
                                     *mut *const ::std::os::raw::c_void,
                                     p_ret: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn godot_method_bind_call(p_method_bind: *mut godot_method_bind,
                                  p_instance: *mut godot_object,
                                  p_args: *mut *const godot_variant,
                                  p_arg_count: ::std::os::raw::c_int,
                                  p_call_error: *mut godot_variant_call_error)
                                  -> godot_variant;
}
////// Script API
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_gdnative_init_options {
    pub in_editor: godot_bool,
    pub core_api_hash: u64,
    pub editor_api_hash: u64,
    pub no_api_hash: u64,
}
#[test]
fn bindgen_test_layout_godot_gdnative_init_options() {
    assert_eq!(::std::mem::size_of::<godot_gdnative_init_options>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( godot_gdnative_init_options ) ));
    assert_eq! (::std::mem::align_of::<godot_gdnative_init_options>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( godot_gdnative_init_options )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_gdnative_init_options ) ) .
            in_editor as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_gdnative_init_options ) , "::" , stringify ! ( in_editor
                ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_gdnative_init_options ) ) .
            core_api_hash as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_gdnative_init_options ) , "::" , stringify ! (
                core_api_hash ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_gdnative_init_options ) ) .
            editor_api_hash as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_gdnative_init_options ) , "::" , stringify ! (
                editor_api_hash ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_gdnative_init_options ) ) .
            no_api_hash as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_gdnative_init_options ) , "::" , stringify ! (
                no_api_hash ) ));
}
impl Clone for godot_gdnative_init_options {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_gdnative_terminate_options {
    pub in_editor: godot_bool,
}
#[test]
fn bindgen_test_layout_godot_gdnative_terminate_options() {
    assert_eq!(::std::mem::size_of::<godot_gdnative_terminate_options>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( godot_gdnative_terminate_options )
               ));
    assert_eq! (::std::mem::align_of::<godot_gdnative_terminate_options>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                godot_gdnative_terminate_options ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_gdnative_terminate_options ) ) .
            in_editor as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_gdnative_terminate_options ) , "::" , stringify ! (
                in_editor ) ));
}
impl Clone for godot_gdnative_terminate_options {
    fn clone(&self) -> Self { *self }
}
pub type godot_class_constructor =
::std::option::Option<unsafe extern "C" fn() -> *mut godot_object>;
extern "C" {
    pub fn godot_get_class_constructor(p_classname:
                                       *const ::std::os::raw::c_char)
                                       -> godot_class_constructor;
}
extern "C" {
    pub fn godot_get_global_constants() -> godot_dictionary;
}
////// GDNative procedure types
pub type godot_gdnative_init_fn =
::std::option::Option<unsafe extern "C" fn(arg1:
                                           *mut godot_gdnative_init_options)>;
pub type godot_gdnative_terminate_fn =
::std::option::Option<unsafe extern "C" fn(arg1:
                                           *mut godot_gdnative_terminate_options)>;
pub type godot_gdnative_procedure_fn =
::std::option::Option<unsafe extern "C" fn(arg1:
                                           *mut ::std::os::raw::c_void,
                                           arg2: *mut godot_array)
                                           -> godot_variant>;
extern "C" {
    ////// System Functions
    pub fn godot_alloc(p_bytes: ::std::os::raw::c_int)
                       -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn godot_realloc(p_ptr: *mut ::std::os::raw::c_void,
                         p_bytes: ::std::os::raw::c_int)
                         -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn godot_free(p_ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn godot_print_error(p_description: *const ::std::os::raw::c_char,
                             p_function: *const ::std::os::raw::c_char,
                             p_file: *const ::std::os::raw::c_char,
                             p_line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn godot_print_warning(p_description: *const ::std::os::raw::c_char,
                               p_function: *const ::std::os::raw::c_char,
                               p_file: *const ::std::os::raw::c_char,
                               p_line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn godot_print(p_message: *const godot_string);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_method_rpc_mode {
    GODOT_METHOD_RPC_MODE_DISABLED = 0,
    GODOT_METHOD_RPC_MODE_REMOTE = 1,
    GODOT_METHOD_RPC_MODE_SYNC = 2,
    GODOT_METHOD_RPC_MODE_MASTER = 3,
    GODOT_METHOD_RPC_MODE_SLAVE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_property_hint {
    GODOT_PROPERTY_HINT_NONE = 0,
    GODOT_PROPERTY_HINT_RANGE = 1,
    GODOT_PROPERTY_HINT_EXP_RANGE = 2,
    GODOT_PROPERTY_HINT_ENUM = 3,
    GODOT_PROPERTY_HINT_EXP_EASING = 4,
    GODOT_PROPERTY_HINT_LENGTH = 5,
    GODOT_PROPERTY_HINT_SPRITE_FRAME = 6,
    GODOT_PROPERTY_HINT_KEY_ACCEL = 7,
    GODOT_PROPERTY_HINT_FLAGS = 8,
    GODOT_PROPERTY_HINT_LAYERS_2D_RENDER = 9,
    GODOT_PROPERTY_HINT_LAYERS_2D_PHYSICS = 10,
    GODOT_PROPERTY_HINT_LAYERS_3D_RENDER = 11,
    GODOT_PROPERTY_HINT_LAYERS_3D_PHYSICS = 12,
    GODOT_PROPERTY_HINT_FILE = 13,
    GODOT_PROPERTY_HINT_DIR = 14,
    GODOT_PROPERTY_HINT_GLOBAL_FILE = 15,
    GODOT_PROPERTY_HINT_GLOBAL_DIR = 16,
    GODOT_PROPERTY_HINT_RESOURCE_TYPE = 17,
    GODOT_PROPERTY_HINT_MULTILINE_TEXT = 18,
    GODOT_PROPERTY_HINT_COLOR_NO_ALPHA = 19,
    GODOT_PROPERTY_HINT_IMAGE_COMPRESS_LOSSY = 20,
    GODOT_PROPERTY_HINT_IMAGE_COMPRESS_LOSSLESS = 21,
    GODOT_PROPERTY_HINT_OBJECT_ID = 22,
    GODOT_PROPERTY_HINT_TYPE_STRING = 23,
    GODOT_PROPERTY_HINT_NODE_PATH_TO_EDITED_NODE = 24,
    GODOT_PROPERTY_HINT_METHOD_OF_VARIANT_TYPE = 25,
    GODOT_PROPERTY_HINT_METHOD_OF_BASE_TYPE = 26,
    GODOT_PROPERTY_HINT_METHOD_OF_INSTANCE = 27,
    GODOT_PROPERTY_HINT_METHOD_OF_SCRIPT = 28,
    GODOT_PROPERTY_HINT_PROPERTY_OF_VARIANT_TYPE = 29,
    GODOT_PROPERTY_HINT_PROPERTY_OF_BASE_TYPE = 30,
    GODOT_PROPERTY_HINT_PROPERTY_OF_INSTANCE = 31,
    GODOT_PROPERTY_HINT_PROPERTY_OF_SCRIPT = 32,
    GODOT_PROPERTY_HINT_MAX = 33,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum godot_property_usage_flags {
    GODOT_PROPERTY_USAGE_STORAGE = 1,
    GODOT_PROPERTY_USAGE_EDITOR = 2,
    GODOT_PROPERTY_USAGE_NETWORK = 4,
    GODOT_PROPERTY_USAGE_EDITOR_HELPER = 8,
    GODOT_PROPERTY_USAGE_CHECKABLE = 16,
    GODOT_PROPERTY_USAGE_CHECKED = 32,
    GODOT_PROPERTY_USAGE_INTERNATIONALIZED = 64,
    GODOT_PROPERTY_USAGE_GROUP = 128,
    GODOT_PROPERTY_USAGE_CATEGORY = 256,
    GODOT_PROPERTY_USAGE_STORE_IF_NONZERO = 512,
    GODOT_PROPERTY_USAGE_STORE_IF_NONONE = 1024,
    GODOT_PROPERTY_USAGE_NO_INSTANCE_STATE = 2048,
    GODOT_PROPERTY_USAGE_RESTART_IF_CHANGED = 4096,
    GODOT_PROPERTY_USAGE_SCRIPT_VARIABLE = 8192,
    GODOT_PROPERTY_USAGE_STORE_IF_NULL = 16384,
    GODOT_PROPERTY_USAGE_ANIMATE_AS_TRIGGER = 32768,
    GODOT_PROPERTY_USAGE_UPDATE_ALL_IF_MODIFIED = 65536,
    GODOT_PROPERTY_USAGE_DEFAULT = 7,
    GODOT_PROPERTY_USAGE_DEFAULT_INTL = 71,
    GODOT_PROPERTY_USAGE_NOEDITOR = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_property_attributes {
    pub rset_type: godot_method_rpc_mode,
    pub type_: godot_int,
    pub hint: godot_property_hint,
    pub hint_string: godot_string,
    pub usage: godot_property_usage_flags,
    pub default_value: godot_variant,
}
#[test]
fn bindgen_test_layout_godot_property_attributes() {
    assert_eq!(::std::mem::size_of::<godot_property_attributes>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_property_attributes ) ));
    assert_eq! (::std::mem::align_of::<godot_property_attributes>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_property_attributes )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_attributes ) ) . rset_type
            as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( rset_type )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_attributes ) ) . type_ as
            * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_attributes ) ) . hint as *
        const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( hint ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_attributes ) ) .
            hint_string as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( hint_string
                ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_attributes ) ) . usage as
            * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! ( usage ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_attributes ) ) .
            default_value as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_property_attributes ) , "::" , stringify ! (
                default_value ) ));
}
impl Clone for godot_property_attributes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_instance_create_func {
    pub create_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut godot_object,
                                                                arg2:
                                                                *mut ::std::os::raw::c_void)
                                                                ->
                                                                *mut ::std::os::raw::c_void>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_instance_create_func() {
    assert_eq!(::std::mem::size_of::<godot_instance_create_func>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_instance_create_func ) ));
    assert_eq! (::std::mem::align_of::<godot_instance_create_func>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( godot_instance_create_func )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_create_func ) ) .
            create_func as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_create_func ) , "::" , stringify ! (
                create_func ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_create_func ) ) .
            method_data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_create_func ) , "::" , stringify ! (
                method_data ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_create_func ) ) .
            free_func as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_create_func ) , "::" , stringify ! ( free_func
                ) ));
}
impl Clone for godot_instance_create_func {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_instance_destroy_func {
    pub destroy_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut godot_object,
                                                                 arg2:
                                                                 *mut ::std::os::raw::c_void,
                                                                 arg3:
                                                                 *mut ::std::os::raw::c_void)>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_instance_destroy_func() {
    assert_eq!(::std::mem::size_of::<godot_instance_destroy_func>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( godot_instance_destroy_func ) ));
    assert_eq! (::std::mem::align_of::<godot_instance_destroy_func>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( godot_instance_destroy_func )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_destroy_func ) ) .
            destroy_func as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_destroy_func ) , "::" , stringify ! (
                destroy_func ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_destroy_func ) ) .
            method_data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_destroy_func ) , "::" , stringify ! (
                method_data ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_destroy_func ) ) .
            free_func as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                godot_instance_destroy_func ) , "::" , stringify ! ( free_func
                ) ));
}
impl Clone for godot_instance_destroy_func {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_nativescript_register_class(p_gdnative_handle:
                                             *mut ::std::os::raw::c_void,
                                             p_name:
                                             *const ::std::os::raw::c_char,
                                             p_base:
                                             *const ::std::os::raw::c_char,
                                             p_create_func:
                                             godot_instance_create_func,
                                             p_destroy_func:
                                             godot_instance_destroy_func);
}
extern "C" {
    pub fn godot_nativescript_register_tool_class(p_gdnative_handle:
                                                  *mut ::std::os::raw::c_void,
                                                  p_name:
                                                  *const ::std::os::raw::c_char,
                                                  p_base:
                                                  *const ::std::os::raw::c_char,
                                                  p_create_func:
                                                  godot_instance_create_func,
                                                  p_destroy_func:
                                                  godot_instance_destroy_func);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_method_attributes {
    pub rpc_type: godot_method_rpc_mode,
}
#[test]
fn bindgen_test_layout_godot_method_attributes() {
    assert_eq!(::std::mem::size_of::<godot_method_attributes>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_method_attributes ) ));
    assert_eq! (::std::mem::align_of::<godot_method_attributes>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_method_attributes ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_method_attributes ) ) . rpc_type as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_method_attributes
                ) , "::" , stringify ! ( rpc_type ) ));
}
impl Clone for godot_method_attributes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_instance_method {
    pub method: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                           *mut godot_object,
                                                           arg2:
                                                           *mut ::std::os::raw::c_void,
                                                           arg3:
                                                           *mut ::std::os::raw::c_void,
                                                           arg4:
                                                           ::std::os::raw::c_int,
                                                           arg5:
                                                           *mut *mut godot_variant)
                                                           -> godot_variant>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_instance_method() {
    assert_eq!(::std::mem::size_of::<godot_instance_method>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( godot_instance_method )
               ));
    assert_eq! (::std::mem::align_of::<godot_instance_method>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_instance_method ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_method ) ) . method as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_instance_method )
                , "::" , stringify ! ( method ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_method ) ) . method_data
            as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_instance_method )
                , "::" , stringify ! ( method_data ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_instance_method ) ) . free_func as
            * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_instance_method )
                , "::" , stringify ! ( free_func ) ));
}
impl Clone for godot_instance_method {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_nativescript_register_method(p_gdnative_handle:
                                              *mut ::std::os::raw::c_void,
                                              p_name:
                                              *const ::std::os::raw::c_char,
                                              p_function_name:
                                              *const ::std::os::raw::c_char,
                                              p_attr: godot_method_attributes,
                                              p_method:
                                              godot_instance_method);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_property_set_func {
    pub set_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             *mut godot_object,
                                                             arg2:
                                                             *mut ::std::os::raw::c_void,
                                                             arg3:
                                                             *mut ::std::os::raw::c_void,
                                                             arg4:
                                                             *mut godot_variant)>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_property_set_func() {
    assert_eq!(::std::mem::size_of::<godot_property_set_func>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_property_set_func ) ));
    assert_eq! (::std::mem::align_of::<godot_property_set_func>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_property_set_func ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_set_func ) ) . set_func as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_set_func
                ) , "::" , stringify ! ( set_func ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_set_func ) ) . method_data
            as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_set_func
                ) , "::" , stringify ! ( method_data ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_set_func ) ) . free_func
            as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_set_func
                ) , "::" , stringify ! ( free_func ) ));
}
impl Clone for godot_property_set_func {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_property_get_func {
    pub get_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             *mut godot_object,
                                                             arg2:
                                                             *mut ::std::os::raw::c_void,
                                                             arg3:
                                                             *mut ::std::os::raw::c_void)
                                                             -> godot_variant>,
    pub method_data: *mut ::std::os::raw::c_void,
    pub free_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_godot_property_get_func() {
    assert_eq!(::std::mem::size_of::<godot_property_get_func>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( godot_property_get_func ) ));
    assert_eq! (::std::mem::align_of::<godot_property_get_func>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_property_get_func ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_get_func ) ) . get_func as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_get_func
                ) , "::" , stringify ! ( get_func ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_get_func ) ) . method_data
            as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_get_func
                ) , "::" , stringify ! ( method_data ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_property_get_func ) ) . free_func
            as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_property_get_func
                ) , "::" , stringify ! ( free_func ) ));
}
impl Clone for godot_property_get_func {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_nativescript_register_property(p_gdnative_handle:
                                                *mut ::std::os::raw::c_void,
                                                p_name:
                                                *const ::std::os::raw::c_char,
                                                p_path:
                                                *const ::std::os::raw::c_char,
                                                p_attr:
                                                *mut godot_property_attributes,
                                                p_set_func:
                                                godot_property_set_func,
                                                p_get_func:
                                                godot_property_get_func);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_signal_argument {
    pub name: godot_string,
    pub type_: godot_int,
    pub hint: godot_property_hint,
    pub hint_string: godot_string,
    pub usage: godot_property_usage_flags,
    pub default_value: godot_variant,
}
#[test]
fn bindgen_test_layout_godot_signal_argument() {
    assert_eq!(::std::mem::size_of::<godot_signal_argument>() , 52usize ,
               concat ! ( "Size of: " , stringify ! ( godot_signal_argument )
               ));
    assert_eq! (::std::mem::align_of::<godot_signal_argument>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( godot_signal_argument ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal_argument ) ) . name as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal_argument ) ) . type_ as *
        const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal_argument ) ) . hint as *
        const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( hint ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal_argument ) ) . hint_string
            as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( hint_string ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal_argument ) ) . usage as *
        const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( usage ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal_argument ) ) . default_value
            as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal_argument )
                , "::" , stringify ! ( default_value ) ));
}
impl Clone for godot_signal_argument {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct godot_signal {
    pub name: godot_string,
    pub num_args: ::std::os::raw::c_int,
    pub args: *mut godot_signal_argument,
    pub num_default_args: ::std::os::raw::c_int,
    pub default_args: *mut godot_variant,
}
#[test]
fn bindgen_test_layout_godot_signal() {
    assert_eq!(::std::mem::size_of::<godot_signal>() , 40usize , concat ! (
               "Size of: " , stringify ! ( godot_signal ) ));
    assert_eq! (::std::mem::align_of::<godot_signal>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( godot_signal ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal ) ) . name as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal ) ) . num_args as * const _
            as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( num_args ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal ) ) . args as * const _ as
            usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal ) ) . num_default_args as *
        const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( num_default_args ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const godot_signal ) ) . default_args as *
        const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( godot_signal ) , "::" ,
                stringify ! ( default_args ) ));
}
impl Clone for godot_signal {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn godot_nativescript_register_signal(p_gdnative_handle:
                                              *mut ::std::os::raw::c_void,
                                              p_name:
                                              *const ::std::os::raw::c_char,
                                              p_signal: *const godot_signal);
}
extern "C" {
    pub fn godot_nativescript_get_userdata(p_instance: *mut godot_object)
                                           -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
        _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
            * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
        const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
